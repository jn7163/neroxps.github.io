<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[zabbix-agent 安装及升级]]></title>
    <url>%2F2017%2F07%2F15%2FZabbix-agent-installation-Debian%2F</url>
    <content type="text"><![CDATA[安装 zabbix-agent 到 Debian 参考 Zabbix Documentation 3.2 通过默认源安装 zabbix-agent1sudo apt-get install zabbix-agent 但是这样安装的 zabbix-agent 版本是比较老的版本 123zabbix_agent -VZabbix agent v2.2.7 (revision 50148) (24 October 2014)Compilation time: Feb 3 2017 17:23:53 通过 Zabbix 源安装新版本1234567# wget http://repo.zabbix.com/zabbix/3.2/debian/pool/main/z/zabbix-release/zabbix-release_3.2-1+jessie_all.deb# dpkg -i zabbix-release_3.2-1+jessie_all.deb# apt-get update# apt-get install zabbix-agent# zabbix_agentd -Vzabbix_agentd (daemon) (Zabbix) 3.2.6Revision 67849 4 May 2017, compilation time: May 6 2017 15:59:40 升级 zabbix-agent 到官方新版本(2.2.7 升级到 3.2.6）如果是之前安装 zabbix-agent 是用系统默认源安装的话，版本比较久，那么可以通过上面方法安装最新版本。 注：笔者的 zabbix-server 版本是3.2版本，要确定自己的 zabbix-agent 是否适用于 zabbix-server。 123456$ wget http://repo.zabbix.com/zabbix/3.2/debian/pool/main/z/zabbix-release/zabbix-release_3.2-1+jessie_all.deb$ sudo dpkg -i zabbix-release_3.2-1+jessie_all.deb$ sudo apt-get update$ sudo apt-get install --only-upgrade zabbix-agent注意，这里更新的时候会问你选择如何处理已有的配置文件，这里可以选择 N，使用原来的配置文件。 遇到错误安装到最后会报告安装失败，其实已经安装好了，但是因为 2.2 的配置文件引入的其他配置的目录路径是 /etc/zabbix/zabbix_agentd.conf.d，而 3.2是 /etc/zabbix/zabbix_agentd.d 故此会刷出报错日志如下： 1237月 15 14:49:22 gooderp-backup zabbix_agentd[22098]: zabbix_agentd [22098]: /etc/zabbix/zabbix_agentd.conf.d: [2] No such file or directory7月 15 14:49:22 gooderp-backup systemd[1]: zabbix-agent.service: control process exited, code=exited status=17月 15 14:49:22 gooderp-backup systemd[1]: Failed to start Zabbix Agent. 这个简单，只需要替换下配置文件的路径名称即可。 12$ sudo sed -i &quot;s/zabbix_agentd.conf.d/zabbix_agentd.d/g&quot; /etc/zabbix/zabbix_agentd.conf$ sudo systemctl restart zabbix-agent]]></content>
      <categories>
        <category>IT技术 Linux</category>
      </categories>
      <tags>
        <tag>Zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zabbix 邮件警告]]></title>
    <url>%2F2017%2F07%2F13%2FZabbix-SMTP%2F</url>
    <content type="text"><![CDATA[触发器邮件警告Zabbix 默认的邮箱警告有个 SMTP HELO 的值，我一直不知道怎么填写，反正这个值一直报错，网上爬文一堆都是通过脚本来发邮件的。 部署 sendEmail 环境 参考文献1：Zabbix通过stmp邮件报警 参考文献2：zabbix 3.0.2邮件报警 这里需要用到 sendEmail 下载地址，它是基于 perl 写的一个脚本，如果用 SSL 加密的话需要依赖 perl 的 Net::SSLeay 和 IO::Socket::SSL 模块，debian 和 Ubuntu 的源都可以直接安装这个软件，另外安装 libcrypt-ssleay-perl libio-socket-ssl-perl ca-certificates 这三个包即可。 但是我查了下，zabbix/zabbix-server-mysql:latest 是使用 alpine 的，我测试的时候 sendEmail 官网下载的脚本会遇到 invalid SSL_version 的报错。Google 一番后据说要修改 /usr/share/perl5/IO/Socket/SSL.pm 这个依赖文件，但是我改了之后就会报 SSL 鉴定错误，故此不能这样做。 最终爬贴找到了这个帖子1.56-overzealous-version-check.patch 例子中是将 sendEmail 的 SSL_version 定义为 SSLv3，但是我使用的 QQ 邮箱和 Gmail 目前都在使用 TLSv1 协议，故此我需要将这个改成 TLSv1。 说回来我是 Docker 环境，故此我需要基于 zabbix/zabbix-server-mysql:latest 构建一个新的镜像。 1. 创建 Docker 构建文件夹1mkdir ~/zabbix-server-mysql-sendEmail 2. 创建 Dockerfile12345678910111213141516171819202122cat &lt;&lt;EOF | tee ~/zabbix-server-mysql-sendEmail/DockerfileFROM zabbix/zabbix-server-mysqlRUN sed -i &apos;s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g&apos; /etc/apk/repositories &amp;&amp; \apk add --no-cache perl-crypt-ssleay perl-io-socket-ssl ca-certificates tzdata &amp;&amp; \wget http://caspian.dotconf.net/menu/Software/SendEmail/sendEmail-v1.56.tar.gz -P /tmp/ &amp;&amp; \tar xzf /tmp/sendEmail-v1.56.tar.gz -C /tmp/ &amp;&amp; \rm -f /tmp/sendEmail-v1.56.tar.gz &amp;&amp; \sed -i &quot;s/SSL_version =&gt; &apos;SSLv3 TLSv1&apos;/SSL_version =&gt; &apos;TLSv1&apos;/g&quot; /tmp/sendEmail-v1.56/sendEmail &amp;&amp; \mv /tmp/sendEmail-v1.56/sendEmail /usr/bin &amp;&amp; \chmod +x /usr/bin/sendEmail &amp;&amp; \rm -rf /tmp/* &amp;&amp; \ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime &amp;&amp; \echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone EXPOSE 10051/TCP 162/UDPWORKDIR /var/lib/zabbixENTRYPOINT [&quot;/bin/bash&quot;]CMD [&quot;/run_zabbix_component.sh&quot;, &quot;server&quot;, &quot;mysql&quot;]EOF 3. 构建镜像12cd ~/zabbix-server-mysql-sendEmaildocker build -t nero/zabbix-server-mysql:latest . 4. 停止官方使用的镜像，启用新镜像12345678910111213docker rm -f zabbix-server #这里我之前启用镜像的时候使用的是别名docker run --name zabbix-server \--link zabbix-db:mysql-server \--restart=always \-e MYSQL_USER=zabbix \-e MYSQL_PASSWORD=zabbix \-e ZBX_IPMIPOLLERS=3 \-e ZBX_STARTVMWARECOLLECTORS=5 \-e ZBX_DEBUGLEVEL=3 \-v /home/nero/zabbix/externalscripts:/usr/lib/zabbix/externalscripts \-v /home/nero/zabbix/alertscripts:/usr/lib/zabbix/alertscripts \-p 10051:10051 \-d nero/zabbix-server-mysql 5. 编写 sendEmail 的发信脚本 参考自 Zabbix通过stmp邮件报警 我修改了下他的脚本，他脚本会自动转换字符编码，另外输出日志方便排查，但是日志不太详细，我给 sendEmail 加了 -v 参数。 12345678910111213141516171819202122232425262728293031323334#!/bin/bashSMTP_server=&apos;smtp.qq.com:587&apos; # SMTP服务器，我用 QQ TLS 的端口。username=&apos;email@email.com&apos; # 用户名password=&apos; smtp_password&apos; # 密码from_email_address=&apos;email@email.com&apos; # 发件人Email地址to_email_address=&quot;$1&quot; # 收件人Email地址，zabbix传入的第一个参数message_subject_utf8=&quot;$2&quot; # 邮件标题，zabbix传入的第二个参数message_body_utf8=&quot;$3&quot; # 邮件内容，zabbix传入的第三个参数echo &quot;`date +&quot;%F %T&quot;` send to $to_email_address&quot; &gt;&gt; /tmp/send.log# 转换邮件标题为GB2312，解决邮件标题含有中文，收到邮件显示乱码的问题。message_subject_gb2312=`iconv -t GB2312 -f UTF-8 &lt;&lt; EOF$message_subject_utf8EOF`[ $? -eq 0 ] &amp;&amp; message_subject=&quot;$message_subject_gb2312&quot; || message_subject=&quot;$message_subject_utf8&quot;bhnaqekboudsdcca# 转换邮件内容为GB2312message_body_gb2312=`iconv -t GB2312 -f UTF-8 &lt;&lt; EOF$message_body_utf8EOF`[ $? -eq 0 ] &amp;&amp; message_body=&quot;$message_body_gb2312&quot; || message_body=&quot;$message_body_utf8&quot;# 发送邮件sendEmail=&apos;/usr/bin/sendEmail&apos;$sendEmail -s &quot;$SMTP_server&quot; -xu &quot;$username&quot; -xp &quot;$password&quot; -f &quot;$from_email_address&quot; -t &quot;$to_email_address&quot; -u &quot;$message_subject&quot; -m &quot;$message_body&quot; -o message-content-type=text -o message-charset=gb2312 -o tls=yes -v &gt;&gt; /tmp/send.logecho $? &gt;&gt; /tmp/send.logecho &quot;zabbix 参数1 = $1&quot; &gt;&gt; /tmp/send.logecho &quot;zabbix 参数2 = $2&quot; &gt;&gt; /tmp/send.logecho &quot;zabbix 参数3 = $3&quot; &gt;&gt; /tmp/send.logecho &gt;&gt; /tmp/send.logecho &gt;&gt; /tmp/send.logecho &gt;&gt; /tmp/send.log Zabbix 设置邮件告警 我这里的 Zabbix 版本是3.2版本，不同版本界面略有不同，据说2.0的版本不需要加脚本参数，3.0开始需要加脚本参数了。 1. 创建报价媒介类型 2. 输入报警媒介类型参数 这里注意，脚本参数顺序不要错，否则会导致发信失败。 脚本参数 参数 注释 第一个参数 {ALERT.SENDTO} 目的邮箱地址 第二个参数 {ALERT.SUBJECT} 邮件主题 第三个参数 {ALERT.MESSAGE} 邮件内容 3. 配置用户收信邮箱 4. 配置动作这里我建立一个触发器警告，当触发器条件为真的时候，就发出警告邮件。 注意这里事件源选择触发器 按图片重复添加动作条件 1234567891011默认接收人：『服务器警报』 &#123;HOST.NAME&#125;:&#123;ITEM.NAME&#125;默认信息：告警主机: &#123;HOSTNAME1&#125;告警时间: &#123;EVENT.DATE&#125; &#123;EVENT.TIME&#125;告警等级: &#123;TRIGGER.SEVERITY&#125;告警信息: &#123;TRIGGER.NAME&#125;告警项目: &#123;TRIGGER.KEY1&#125;问题详情: &#123;ITEM.NAME&#125;: &#123;ITEM.VALUE&#125;当前状态: &#123;TRIGGER.STATUS&#125;: &#123;ITEM.VALUE1&#125;事件ID: &#123;EVENT.ID&#125; 其余参数按照图片设置，目前还没理解透这里所有选项，这里就不班门弄斧。 这里是触发器值为假后的操作，你可以自定义恢复公式，也可以按照原来的公式为假后发送邮件，告诉我们这个监控值正常了。 里面的内容除了默认接收人也就是邮件标题外，其余内容和上面的一样。 调试邮件告警监控邮件发送日志，就可以调试邮件的发送状态了。 1234567891011121314151617181920212223242526272829303132333435363738394041docker exec -it zabbix-server tail -f /tmp/send.log2017-07-12 17:53:07 send to neroxps@gmail.comJul 12 17:53:07 1890ce4a57bf sendEmail[172]: DEBUG =&gt; Connecting to smtp.qq.com:587Jul 12 17:53:07 1890ce4a57bf sendEmail[172]: DEBUG =&gt; My IP address is: 172.17.0.3Jul 12 17:53:07 1890ce4a57bf sendEmail[172]: SUCCESS =&gt; Received: 220 smtp.qq.com Esmtp QQ Mail ServerJul 12 17:53:07 1890ce4a57bf sendEmail[172]: INFO =&gt; Sending: EHLO Jul 12 17:53:07 1890ce4a57bf sendEmail[172]: SUCCESS =&gt; Received: 250-smtp.qq.com, 250-PIPELINING, 250-SIZE 73400320, 250-STARTTLS, 250-AUTH LOGIN PLAIN, 250-AUTH=LOGIN, 250-MAILCOMPRESS, 250 8BITMIMEJul 12 17:53:07 1890ce4a57bf sendEmail[172]: INFO =&gt; Sending: STARTTLSJul 12 17:53:07 1890ce4a57bf sendEmail[172]: SUCCESS =&gt; Received: 220 Ready to start TLSJul 12 17:53:07 1890ce4a57bf sendEmail[172]: DEBUG =&gt; TLS session initialized :)Jul 12 17:53:07 1890ce4a57bf sendEmail[172]: INFO =&gt; Sending: EHLO Jul 12 17:53:07 1890ce4a57bf sendEmail[172]: SUCCESS =&gt; Received: 250-smtp.qq.com, 250-PIPELINING, 250-SIZE 73400320, 250-AUTH LOGIN PLAIN, 250-AUTH=LOGIN, 250-MAILCOMPRESS, 250 8BITMIMEJul 12 17:53:07 1890ce4a57bf sendEmail[172]: DEBUG =&gt; SMTP-AUTH: Using LOGIN authentication methodJul 12 17:53:07 1890ce4a57bf sendEmail[172]: INFO =&gt; Sending: AUTH LOGINJul 12 17:53:07 1890ce4a57bf sendEmail[172]: SUCCESS =&gt; Received: 334 VXNlcm5hbWU6Jul 12 17:53:07 1890ce4a57bf sendEmail[172]: INFO =&gt; Sending: Jul 12 17:53:07 1890ce4a57bf sendEmail[172]: SUCCESS =&gt; Received: 334 UGFzc3dvcmQ6Jul 12 17:53:07 1890ce4a57bf sendEmail[172]: INFO =&gt; Sending: Jul 12 17:53:08 1890ce4a57bf sendEmail[172]: SUCCESS =&gt; Received: 235 Authentication successfulJul 12 17:53:08 1890ce4a57bf sendEmail[172]: DEBUG =&gt; User authentication was successful (Method: LOGIN)Jul 12 17:53:08 1890ce4a57bf sendEmail[172]: INFO =&gt; Sending: MAIL FROM:&lt;email@email.com&gt;Jul 12 17:53:08 1890ce4a57bf sendEmail[172]: SUCCESS =&gt; Received: 250 OkJul 12 17:53:08 1890ce4a57bf sendEmail[172]: INFO =&gt; Sending: RCPT TO:&lt;neroxps@gmail.com&gt;Jul 12 17:53:08 1890ce4a57bf sendEmail[172]: SUCCESS =&gt; Received: 250 OkJul 12 17:53:08 1890ce4a57bf sendEmail[172]: INFO =&gt; Sending: DATAJul 12 17:53:08 1890ce4a57bf sendEmail[172]: SUCCESS =&gt; Received: 354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;Jul 12 17:53:08 1890ce4a57bf sendEmail[172]: INFO =&gt; Sending message bodyJul 12 17:53:08 1890ce4a57bf sendEmail[172]: Setting content-type: text/plainJul 12 17:53:08 1890ce4a57bf sendEmail[172]: SUCCESS =&gt; Received: 250 Ok: queued asJul 12 17:53:08 1890ce4a57bf sendEmail[172]: Email was sent successfully! From: &lt;email@email.com&gt; To: &lt;neroxps@gmail.com&gt; Subject: [『服务器警报恢复』 Gen8-ipmi:02-CPU] Server: [smtp.qq.com:587]0zabbix 参数1 = neroxps@gmail.comzabbix 参数2 = 『服务器警报恢复』 Gen8-ipmi:02-CPUzabbix 参数3 = 告警主机: Gen8-ipmi告警时间: 2017.07.12 17:50:58告警等级: High告警信息: Gen8-ipmi CPU温度过高-test006告警项目: 02-CPU问题详情: 02-CPU: 40 ℃当前状态: OK: 40 ℃事件ID: 4858]]></content>
      <categories>
        <category>IT技术 Linux</category>
      </categories>
      <tags>
        <tag>Zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Docker 部署 Zabbix 3.2 记录]]></title>
    <url>%2F2017%2F07%2F01%2FZabbix-Installation-Docker%2F</url>
    <content type="text"><![CDATA[Zabbix 搭建文档概述计划使用 docker 搭建 Zabbix 监控系统。 安装 Docker参考 Ubuntu、Debian 系列安装 Docker 部署 Mariadb-Server一、建立数据库本地目录12mkdir -p ~/zabbix/database/mysqlmkdir ~/zabbix/database/conf.d 二、运行 Mariadb-Server Docker123456789docker run --name zabbix-db \--restart=always \-e MYSQL_ROOT_PASSWORD='mysql_root_password' \-e MYSQL_DATABASE=zabbix \-e MYSQL_USER=zabbix \-e MYSQL_PASSWORD=zabbix \-v /home/nero/zabbix/database/mysql:/var/lib/mysql \-v /home/nero/zabbix/database/conf.d:/etc/mysql/conf.d \-d mariadb 这里会产生一个问题，由于默认的 mariadb 是使用latin1字符集来创建数据库，这时候我们在 Zabbix 录入中文字符的时候会导致出错，故此需要进入 mariadb-docker 内删除新建好的zabbix数据库，再使用utf8新建数据库。 123$ docker exec -it zabbix-db mysql -uroot -p'mysql_root_password'MariaDB [(none)]&gt; drop database zabbix;MariaDB [(none)]&gt; create database zabbix default charset utf8; 此时，数据库已经以 utf8 新建好了。 123456789MariaDB [(none)]&gt; show create database zabbix;+----------+-----------------------------------------------------------------+| Database | Create Database |+----------+-----------------------------------------------------------------+| zabbix | CREATE DATABASE `zabbix` /*!40100 DEFAULT CHARACTER SET utf8 */ |+----------+-----------------------------------------------------------------+1 row in set (0.01 sec)MariaDB [(none)]&gt;quit 2017年07月15日更新怪自己看文档不仔细，今天扒 zabbix 的部署文档发现，我应该运行 mariadb 容器的时候就要定义数据库字符编码。Zabbix Documentation 3.2-5 Installation from containers 注意，这里我是使用 mariadb，和 zabbix 官方文档使用是 mysql 的 docker，参数会有所不同。 123456789docker run --name zabbix-db \--restart=always \-e MYSQL_ROOT_PASSWORD=&apos;mysql_root_password&apos; \-e MYSQL_DATABASE=zabbix \-e MYSQL_USER=zabbix \-e MYSQL_PASSWORD=zabbix \-v /home/nero/zabbix/database/mysql:/var/lib/mysql \-v /home/nero/zabbix/database/conf.d:/etc/mysql/conf.d \-d mariadb --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci 部署 Zabbix-Server-MySQL Docker1234567docker run --name zabbix-server \--link zabbix-db:mysql-server \--restart=always \-e MYSQL_USER=zabbix \-e MYSQL_PASSWORD=zabbix \-p 10051:10051 \-d zabbix/zabbix-server-mysql 部署 Zabbix-WEB-nginx-MySQL Docerk由于 Zabbix 图形字体中文显示会产生乱码，故此需要将中文字体放入 Zabbix 的 WEB 目录中，并修改一个 php 文件才可以修正中文乱码问题。 一、下载官方 zabbix-web-nginx-mysql 镜像docker pull zabbix-web-nginx-mysql 二、上传中文字体 simhei.ttf（本例使用黑体字体）12mkdir ~/zabbix-web-docker-cnrz #使用 rz 命令传输文件，如何传输本文档不体现 三、编写 Dockerfile 文件123456789cat &lt;&lt;EOF | tee ~/zabbix-web-docker-cn/DockerfileFROM zabbix/zabbix-web-nginx-mysqlCOPY simhei.ttf /usr/share/zabbix/fontsEXPOSE 80/TCP 443/TCPWORKDIR /usr/share/zabbixRUN sed -i 's/graphfont/simhei/g' ./include/defines.inc.phpVOLUME ["/etc/ssl/nginx"]CMD ["/run_zabbix_component.sh", "frontend", "mysql", "nginx"]EOF 四、构建镜像1234567891011121314151617181920212223242526272829$ docker build -t nero/zabbix-web-nginx-mysql .Sending build context to Docker daemon 9.755MBStep 1/7 : FROM zabbix/zabbix-web-nginx-mysql ---- 256dc87663d0Step 2/7 : COPY simhei.ttf /usr/share/zabbix/fonts ---- 5743f1ab270bRemoving intermediate container 78381e68fbbeStep 3/7 : EXPOSE 80/TCP 443/TCP ---- Running in 0c6786e828fc ---- d24d892858a6Removing intermediate container 0c6786e828fcStep 4/7 : WORKDIR /usr/share/zabbix ---- dc7c79f00b1cRemoving intermediate container e6975c59dbc8Step 5/7 : RUN sed -i 's/graphfont/simhei/g' ./include/defines.inc.php ---- Running in 27e5405d3ca7 ---- 6ca4c53d4b51Removing intermediate container 27e5405d3ca7Step 6/7 : VOLUME /etc/ssl/nginx ---- Running in 8f28060ed68e ---- 2b4307bc9c9aRemoving intermediate container 8f28060ed68eStep 7/7 : CMD /run_zabbix_component.sh frontend mysql nginx ---- Running in 184feb09f237 ---- b6da55ae29b6Removing intermediate container 184feb09f237Successfully built b6da55ae29b6Successfully tagged nero/zabbix-web-nginx-mysql:latest 五、运行镜像12345678910docker run --name zabbix-web \--link zabbix-db:mysql-server \--link zabbix-server:zabbix-server \-e MYSQL_USER=zabbix \-e MYSQL_PASSWORD=zabbix \-e PHP_TZ='Asia/Hong_Kong' \-e ZBX_SERVER_NAME='Rslnc monit Server' \-p 80:80 \--restart=always \-d nero/zabbix-web-nginx-mysql 遇到的坑数据库编码格式导致中文输入字符无法保存由于之前使用的 docker 创建的 zabbix 数据库默认是以latin1字符编码创建的，故此在问题输入『消息』的时候会报字符编码错误。 那么数据库里面已经有原始数据存在，所以我需要将数据导出，再将数据转换成utf8编码。 参考：# MySQL数据库从GBK转换到UTF-8最简单解决方案（也适用于其它编码转换） 123456789101112$ docker exec -it zabbix-db bash# mysqldump -d -u root -p'mysql_root_password' zabbix &gt; /etc/mysql/conf.d/zabbix.sql# mysqldump --default-character-set=utf8 -t -u root -p'mysql_root_password' zabbix &gt; /etc/mysql/conf.d/zabbix-data.sql# sed -i 's/latin1/utf8/g' /etc/mysql/conf.d/zabbix.sql# mysql -uroot -p'mysql_root_password'MariaDB [(none)]&gt; drop database zabbix;MariaDB [(none)]&gt; create database zabbix default charset utf8;MariaDB [(none)]&gt; use zabbix;MariaDB [zabbix]&gt; source /etc/mysql/conf.d/zabbix.sqlMariaDB [zabbix]&gt; source /etc/mysql/conf.d/zabbix-data.sqlMariaDB [zabbix]&gt; quit# exit]]></content>
      <categories>
        <category>IT技术 Linux</category>
      </categories>
      <tags>
        <tag>Zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记 GoodERP 部署]]></title>
    <url>%2F2017%2F06%2F15%2FGoodERP-Setup-Debian-8%2F</url>
    <content type="text"><![CDATA[概述 GoodERP 官方网址 GoodERP GitHub GoodERP 核心基于 Odoo 项目 GoodERP 论坛 部署环境 系统：Debian 8 最小化安装 内存：4G 硬盘：40G 参考官方论坛：Debian\ubuntu上源码安装GoodERP GoodERP 需要准备由于 GoodERP 是基于 Odoo 做的二次开发，故此可以参考 Odoo 的源码搭建文档。 Python 2.7 PostgreSQL Nodejs 切换国内163源1234567891011cat &lt;&lt;EOF | sudo tee /etc/apt/sources.listdeb http://mirrors.163.com/debian/ jessie main non-free contribdeb http://mirrors.163.com/debian/ jessie-updates main non-free contribdeb http://mirrors.163.com/debian/ jessie-backports main non-free contribdeb-src http://mirrors.163.com/debian/ jessie main non-free contribdeb-src http://mirrors.163.com/debian/ jessie-updates main non-free contribdeb-src http://mirrors.163.com/debian/ jessie-backports main non-free contribdeb http://mirrors.163.com/debian-security/ jessie/updates main non-free contribdeb-src http://mirrors.163.com/debian-security/ jessie/updates main non-free contribEOFsudo apt update &amp;&amp; sudo apt -y upgrade 安装必要的软件 注意：由于使用了 nodesource.com 的安装脚本，建议搭建翻墙环境运行以下命令 123456789101112sudo apt install -y curl wget git vim unzip python python-setuptools\&amp;&amp; curl -sL https://bootstrap.pypa.io/get-pip.py | sudo -E python - \&amp;&amp; curl -sL https://deb.nodesource.com/setup_6.x | sudo -E bash - \&amp;&amp; sudo apt-get install -y nodejs \&amp;&amp; sudo npm config set registry https://registry.npm.taobao.org \&amp;&amp; sudo npm install -g less \&amp;&amp; sudo apt-get -y build-dep python-lxml \&amp;&amp; sudo apt-get -y install libldap2-dev libsasl2-dev \&amp;&amp; curl -o wkhtmltox.deb -SL http://nightly.odoo.com/extra/wkhtmltox-0.12.1.2_linux-jessie-amd64.deb \&amp;&amp; echo &apos;40e8b906de658a2221b15e4e8cd82565a47d7ee8 wkhtmltox.deb&apos; | sha1sum -c - \&amp;&amp; sudo dpkg --force-depends -i wkhtmltox.deb \&amp;&amp; sudo apt-get -y install -f --no-install-recommends PostgreSQL 安装通过 apt-get 安装 PostgreSQL1sudo apt-get install -y postgresql postgresql-server-dev-9.4 配置 PostgreSQL1sudo -u postgres createuser --createdb --no-createrole --no-superuser --pwprompt good #创建数据库用户good，输入两次密码good GoodERP 安装步骤1：新建 good 用户123sudo adduser goodsudo su goodcd ~ 步骤2：从 Github 中下载 GoodERP 源代码123git clone http://github.com/osbzr/gooderp_addons git clone http://github.com/osbzr/baseexit 步骤3：修改 pip 源为国内源（豆瓣）12345sudo mkdir ~/.pipcat &lt;&lt;EOF | sudo tee ~/.pip/pip.conf[global]index-url = https://pypi.douban.com/simpleEOF 步骤4：使用 pip 安装 GoodERP 的 Python 模块（这里的过程会很漫长）12sudo pip install -r base/requirements.txt -i https://pypi.douban.com/simple \&amp;&amp; sudo pip install simplejson httplib2 -i https://pypi.douban.com/simple 配置 GoodERP编辑 ~/gooderp.conf1234567cat &lt;&lt;EOF | tee ~/gooderp.conf[options]db_user = gooddb_password = goodaddons_path = /home/good/gooderp_addonslogfile = /home/good/gooderp.logEOF 开机启动1. 创建服务文件123456789101112131415cat &lt;&lt;EOF | sudo tee /etc/systemd/system/gooderp.service [Unit]Description=GoodERPDocumentation=http://www.gooderp.org/After=network.target postgresql.service[Service]# Ubuntu/Debian convention:Type=simpleUser=goodExecStart=/usr/bin/python /home/good/base/odoo-bin -c /home/good/gooderp.conf[Install]WantedBy=multi-user.targetEOF 2. 让配置文件生效1sudo systemctl daemon-reload 3.设置开机启动123sudo systemctl enable gooderp.servicesudo systemctl enable postgresql.servicesudo systemctl start gooderp.service]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ERP</tag>
        <tag>Linux</tag>
        <tag>GoodERP</tag>
        <tag>Odoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给 Seafile 部署 onlyoffice]]></title>
    <url>%2F2017%2F05%2F27%2F%E7%BB%99_Seafile_%E9%83%A8%E7%BD%B2_onlyoffice%2F</url>
    <content type="text"><![CDATA[安装 Docker 参考 《Docker 从入门到实践》 我是在 Centos 7下搭建 Seafile，这里使用阿里云的 Centos 7 Docker 安装脚本。 1curl -sSL http://acs-public-mirror.oss-cn-hangzhou.aliyuncs.com/docker-engine/internet | sh - 给 Docker 添加加速器因为 Docker 的镜像服务器是在国外，所以我们给 Docker 添加国内镜像加速器，这里我使用阿里云的镜像加速器，如何申请阿里云的镜像加速器请自行百度。 编辑 /usr/lib/systemd/system/docker.service 找到 ExecStart=/usr/bin/dockerd 改成如下配置 1ExecStart=/usr/bin/dockerd --registry-mirror=https://xxxxxxxx.mirror.aliyuncs.com 注：–registry-mirror= 后的网址请修改成阿里云申请的加速器地址 修改后重载 systemd 配置、启动 Docker、设置 Docker 为开机自启动。 123systemctl daemon-reloadsystemctl start dockersystemctl enable docker 部署 OnlyOffice-documentserver 构建 OnlyOffice-documentserver 镜像 这里，你有两个选择 部署官方的 onlyoffice Docker 镜像，但因为官方的 Docker 镜像里没有中文字体，故此显示中文字体上会出现各种异常。 我基于官方的 Docker 镜像制作了一个 Dockerfile 项目地址，只要利用这个 Dockerfile 构建镜像即可。 123git clone https://github.com/neroxps/Docker-Only-Office-Chinese-font.gitcd Docker-Only-Office-Chinese-fontdocker build -t onlyoffice/chinese . winfont 目录下是 windows 下的中文字体，如果你有其他字体需要，也可以将字体上传到这个目录里面，再构建镜像。 构建完毕后查看下我们现在的镜像 1234[root@seafile-server Docker-Only-Office-Chinese-font]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEonlyoffice/chinese latest 5065553b1240 About a minute ago 1.68GBonlyoffice/documentserver latest f5ff5f9ec0c4 2 weeks ago 1.41GB onlyoffice 的 documentserver 镜像是提供在线编辑服务的，镜像内已包含了 nginx 服务器，支持 80 端口和 443 端口，如果有合法证书，我们可以使用 https 连接。 onlyoffice-documentserver Docker 使用方法参考 Docker-DocumentServer 将证书复制到 onlyoffice 证书目录路径 12345#假设当前目录在证书目录下mkdir -p /app/onlyoffice/DocumentServer/data/certscp fullchain1.pem /app/onlyoffice/DocumentServer/data/certs/onlyoffice.crtcp privkey1.pem /app/onlyoffice/DocumentServer/data/certs/onlyoffice.keyopenssl dhparam -out /app/onlyoffice/DocumentServer/data/certs/dhparam.pem 2048 生成 onlyoffice 日志目录 1mkdir -p /app/onlyoffice/DocumentServer/logs 运行 OnlyOffice-documentserver完成部署后我们就可以运行 OnlyOffice-documentserver 了。 由于我的 Seafile 是用 nginx 部署了 https，443端口已被占用了，大家如果公网 ip 多可以忽略，我是部署在内网，公网是 ADSL，故此只有一个公网 ip，所以 OnlyOffice-documentserver 不能使用 443 端口了。 使用 https 1234docker run -itd -p 7443:443 -v /app/onlyoffice/DocumentServer/data:/var/www/onlyoffice/Data \-v /app/onlyoffice/DocumentServer/logs:/var/log/onlyoffice \--restart=always \--name office onlyoffice/chinese 使用 http 1234docker run -itd -p 780:80 -v /app/onlyoffice/DocumentServer/data:/var/www/onlyoffice/Data \-v /app/onlyoffice/DocumentServer/logs:/var/log/onlyoffice \--restart=always \--name office onlyoffice/chinese 这时候我们可以运行 docker logs office 来观察运行情况。 1234567891011[root@seafile-server certs]# docker logs officeguest * Starting PostgreSQL 9.3 database server [ OK ] * Starting message broker rabbitmq-server [ OK ] Starting redis-server: redis-server.Starting supervisor: supervisord.Generating AllFonts.js, please wait...Doneonlyoffice-documentserver:docservice: stoppedonlyoffice-documentserver:docservice: startedonlyoffice-documentserver:converter: stoppedonlyoffice-documentserver:converter: started 通过 web 访问 https://demo.domain.com:7443 可以看到 『Document Server is running』表明服务已经正常运行了。 配置 Seafile 6.1.0，让其使用 onlyoffice 参考 Seafile Manual/Only Office 编辑 seahub_settings.py 加入下方配置 12345# Enable Only OfficeENABLE_ONLYOFFICE = TrueVERIFY_ONLYOFFICE_CERTIFICATE = TrueONLYOFFICE_APIJS_URL = &apos;https://demo.domain.com:7443/web-apps/apps/api/documents/api.js&apos;ONLYOFFICE_FILE_EXTENSION = (&apos;doc&apos;, &apos;docx&apos;, &apos;ppt&apos;, &apos;pptx&apos;, &apos;xls&apos;, &apos;xlsx&apos;, &apos;odt&apos;, &apos;fodt&apos;, &apos;odp&apos;, &apos;fodp&apos;, &apos;ods&apos;, &apos;fods&apos;) 注1：其中 VERIFY_ONLYOFFICE_CERTIFICATE 选项如果 onlyoffice 使用了 https 的话可以选择更改为 True 提高安全性，如果是使用 http 协议则改为 False 注2：如果没使用 memcached 的话，还需要执行 rm /tmp/seahub_cached/清空缓存 重启 seahub 使得配置生效 123#假设当前在 seafile-server-latest 目录下rm -f ../conf/seahub_settings.pyc./seahub.sh restart-fastcgi 尽情享受吧！ 使用体会onlyoffice 还是不错的，加载速度快，界面友善，我与同事测试过，多人同时编辑一个文件的时候毫无问题。 但是它目前缺点也十分明显，界面没有中文语言，对中文支持也不好，例如我们在 word 里面的字体叫『等线』，但是 onlyoffice 里面叫 『DengXian』，有时候它并不能识别，故此会识别成默认英文字体，导致一堆口口。 据说 Seafile 在端午节后会着重优化 onlyoffice 的体验，我们期待吧。]]></content>
      <categories>
        <category>Seafile</category>
      </categories>
      <tags>
        <tag>seafile</tag>
        <tag>onlyoffice</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近小记（2017年04月18日）]]></title>
    <url>%2F2017%2F04%2F18%2F2017-04-18-blog%2F</url>
    <content type="text"><![CDATA[开年至今，一直非常忙碌，过年前后将老婆公司送的华硕 VM510LI 装成黑苹果，并逐步完善了。 但是好景不长，更新 macOS 10.12.4 正式版后睡眠唤醒屏幕无显示，仅有背光。郁闷了我很久，该情况在10.12.3也出现，后来更换显卡 ig 解决的，现在又出现，我将情况发到 tonymacx86 请教 RehabMan 大神（macOS10.12.4 Wake up black screen(Only backlight)），谁知道大神给我说，我的 hotpatch 太复杂了，他也没空调试，让我使用静态方式来修改 ACPI。 只是最近工作都比较多，屁事一堆，今天终于比较有空，继续研究下怎么修复这个问题。（然而既然有空搞，为何浪费时间来写这篇废话呢？xD）]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使二合一声卡耳机麦克风生效整理]]></title>
    <url>%2F2017%2F03%2F13%2FCombo-Audio-Ext-Mic%2F</url>
    <content type="text"><![CDATA[前言自我这台华硕 VM510LI 安装黑苹果以来一直留下两个问题未解决，一是 VGA，二是耳机麦克风无输入。今天终于在远景坛友关云长羽帖子的帮助下解决了麦克风无输入的问题。 帖子链接：【声卡驱动完善进阶】——关于耳机杂音解决办法及三节点信息驱动双麦克风的猜想 修改 AppleALC过程整理根据关云长羽的帖子，启发了我，我是 ALC233，和他的声卡一摸一样，但是我们两个的 Codec 并不一样，他内置麦克风有效节点是 Node 0x1a 而我的是 Node 0x1b，故此我并不可以直接使用他的驱动以及方法。 后来我看他的过程，是使用 layout13，他 layout13 本来就有 LineIn 这个线路输入节点，而我并没有，Pathmap 里面也没有关于 0x19 （25）节点的路径，故此我声卡要耳机麦克风生效的话，必须使用符合以下条件。 layout4.xml 设定 Inputs 的 Mic 和 LineIn。 添加 LineIn 的 MuteGPIO（如果你的节点是 VREF_80 或者其他数值的话） PlatformsX.xml 中需要添加 Node 0X19 的有效路径。 PinConfigData.kext 里添加 Node 0x19的 ConfigData。 关于 LineIn 这个节点查找，为何是0X19，关云长羽原贴上有说，而我猜测是不是和修改 Pin Widget Control 后耳机正常无杂音的节点有关系？关于耳机杂音问题参考我之前写的帖子：http://bbs.pcbeta.com/viewthread-1733228-1-1.html layout4.xml MuteGPIO 由 Noid 0x19 的VREF_80 0x50+0x0100+0x19 &gt; 1342242841（我的 Node 节点是 VREF_HIZ，但是从 ID3 和 ID13 提取的都有这个，当时我不确定是否这个值会影响结果，故此我也加进去了） SignalProcessing 可以放在 Mic，也可以放在 LineIn，放在那里那里就有麦克风降噪。详细可以看看紫米的帖子完整製作仿冒 LegacyHDA.kext (12/16) Platforms4.xml在 AppleALC 里面，ALC233 ID4 的 PathMaps 是没有 Node 0x19 的路径的，因为 Node 19在我们的 Codec 里面根本不是有效节点。 但既然关云长羽说尝试一下将 Node 0x19这个当成有效的 LineIn 节点来做，那么我就直接按照仿冒贴的方法，找到 0X19的 PathMaps。（怎么找请看上面说到的紫米帖） PinConfigData.kext 添加 Node 0X19 的 ConfigData这里我偷了下懒，直接从 ID3 和 ID13 复制了 019开头的四组节点信息过来，因为同款声卡，Codec 是一样的，既然前人已经写了数据，那么应该差不了多少。 提取 AppleALC ID4 的 ConfigData 123401471C10 01471D00 01471E17 01471F90 01B71C20 01B71D00 01B71EA0 01B71F90 02171C30 02171D10 02171E21 02171F01 01470C02 AppleALC 提取的 ID13 123401471C10 01471D00 01471E17 01471F99 02171C20 02171D10 02171E21 02171F03 01A71C30 01A71D01 01A71EA0 01A71F99 01971C40 01971D10 01971E81 01971F03 后来我将 Node 0X19 从 ID13提取出来，然后放入 ID4 的 ConfigData 中，最终的 ConfigData（其中我将最后一个数字改成1，并不是必须，我看紫米的帖子后瞎折腾的，后来成功后发现可用，也就留着没改了。） 123401471C10 01471D00 01471E17 01471F90 01B71C10 01B71D00 01B71EA0 01B71F90 02171C30 02171D10 02171E21 02171F01 01971C20 01971D10 01971E81 01971F01 结果OK 修改好 AppleALC 编译后，测试一下关云长羽的方法，的确成功了，线路输入有了，而且也有电频输入。 可是，发现了一个问题，第二次插入后再也无法切换回线路输入，而且耳机插入后，又像以前那样只有背景声了。（感觉问题更糟糕了） 用 EAPD-Codec-Commander-master RM 项目的 widget_dump.sh 查看，发现一开机因为我用了脚本，开机是设置 0X19为24，故此第一次插入是正常的，然而拔出后，0X19变成02了，而 0X1B（内置麦克风节点）变成24，再插入耳机，这两个数字不会变了，一直是那样。 后来反复研究无果，编译 AppleALC，修改了无数遍 layout 和 Pathmap，折腾的死去活来的。 第二天，复习关云长羽的帖子，发现他提到的 ALCPlugFix 帖子，我又去看了下这个项目的代码和关云长羽提到的 main.m 文件源码部分，不会编程，但是我发现了一个比较有趣的地方。 使用 ALCPlugFix 解决耳机插入拔出的 Pin Widget Control 设定ALCPlugFix 这个程序，作者没有写任何的说明，我也是从关云长羽的帖子得知这个程序。 ALCPlugFix 项目地址 后来发现个程序会检测耳机的插入和拔出情况，根据插入或者拔出，可以运行 Shell。 我现在需要的就是： 插入耳机的时候 Node 0x19 Pin Widget Control 为 24，Node 0X1B Pin Widget Control 为 02。 拔出耳机时候 Node 0x19 Pin Widget Control 为 02，Node 0X1B Pin Widget Control 为 24。 最终我根据上章节结果里截图的设置。并且编译后运行 ALCPlugFix 后，耳机的所有问题都得到解决了。 还发现作者已经写好了开机自运行的安装脚本。 使用方法下载我编译好的 ALCPlugFix.zip（编译只适合 ALC233 的情况，如果是需要运行其他的 hda-verb 命令，自己按照上图填好你需要的 hda-verb 命令。） cd 到 ALCPlugFix 的解压目录，运行以下命令 12sudo chmod +x install.shsudo ./install.sh 脚本会安装 ALCPlugFix 和 hda-verb 到 /usr/bin，然后安装 good.win.ALCPlugFix.plist 自启动服务，并加载。（hda-verb 需要放入 CodecCommander.kext） 和我一样都是 9CC3 的朋友可以直接下载我做好的 AppleALC_For_ALC233_LayoutID4.zip驱动。 提供 AppleALC_For_ALC233_LayoutID4 源码参考]]></content>
      <categories>
        <category>黑苹果</category>
      </categories>
      <tags>
        <tag>黑苹果</tag>
        <tag>Mac</tag>
        <tag>Hackintosh</tag>
        <tag>ASUS</tag>
        <tag>VM510LI</tag>
        <tag>ALC233</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华硕 VM510L EFI 分享 9CC3笔记本主板芯片通用]]></title>
    <url>%2F2017%2F03%2F09%2F9CC3-EFI-README%2F</url>
    <content type="text"><![CDATA[[TOC] 使用说明本文件适用于华硕 9CC3 笔记本芯片组。查看方法，win 下鲁大师 &gt; 详细报表。 本 CLOVER 所有的 ACPI 修改均使用 Hotpatch 方式，补丁模块化，故无 DSDT。 本 EFI 在 VM510LI 测试通过 欢迎各位 9CC3 笔记本芯片组的朋友测试，可加群一齐讨论与反馈问题 QQ 群号:621151130 EFI 下载地址：9CC3-EFI-2017-03-09.zip 目录说明 CLOVER （Clover 目录，请放置在 EFI目录下。需要注意的只有两个地方，CLOVER 的 ACPI 文件夹和 Kext 文件夹。） Hotpatch （ 所使用到的 hotpatch 源代码。） Library/Extensions/DummyX86PP_MBP121_800.kext （建议放在系统盘 /Library/Extensions 下并修复权限，DummyX86PP_MBP121_800.kext 是为了修改 X86PlatformPlugin 中的机型数据，将最低 1300MHz 频率改成最低 800MHz。（可要可不要）） UHD-4K/SSDT-Config.aml（如果是4K 屏幕请替换此文件到 CLOVER/ACPI/patched。 usr/bin/hda-verb （睡眠唤醒无声及开机耳机只有背景声使用，配合 CodecCommander.kext 使用，详见帖子 http://bbs.pcbeta.com/viewthread-1733228-1-1.html ACPI 文件说明SSDT-BATT-VM510LI.aml ASUS R557LI 无需使用此 SSDT，仅需放入 ACPIBatteryManager.kextASUS W519LI 电量无法显示，暂时未知什么问题导致。#2017年03月09日10:24:06 作用： 修复 9CC3 的电量显示，需要配合 ACPIBatteryManager.kext 驱动使用。 使用方法： 在 CLOVER 的 config.list &gt; ACPI &gt; DSDT &gt; Patches 添加以下补丁，并且 SortedOrder 加入 SSDT-BATT-VM510LI.aml EFI &gt; CLOVER &gt; ACPI &gt; Patches 放入本 SSDT。 补丁1： 123Comment：change Method(TACH,1,N) to XACH, optionally pair with SSDT-BATT-VM510LI.amlFind：54414348 09Replace：58414348 09 补丁2： 1234567Comment：change Method(_BIX,0,N) to XBIX, optionally pair with SSDT-BATT-VM510LI.amlFind：5F424958 00Replace：58424958 00``` 补丁3： Comment：change Method(BIFA,0,N) to XIFA, optionally pair with SSDT-BATT-VM510LI.amlFind：42494641 00Replace：58494641 00123补丁4： Comment：change Method(SMBR,3,N) to XMBR, optionally pair with SSDT-BATT-VM510LI.amlFind：534D4252 0BReplace：584D4252 0B123补丁5： Comment：change Method(ECSB,7,N) to XCSB, optionally pair with SSDT-BATT-VM510LI.amlFind：45435342 07Replace：58435342 07123补丁6： Comment：change Method(SMBW,5,N) to XMBW, optionally pair with SSDT-BATT-VM510LI.amlFind：534D4257 0DReplace：584D4257 0D1234567891011121314151617181920212223### SSDT-CodecCommander.aml**作用：**用于配置 CodecCommander.kext，修复睡眠唤醒无声问题。**使用方法：**1. 将本 SSDT 放入 EFI &gt; CLOVER &gt; ACPI &gt; Patches，并且 SortedOrder 加入 SSDT-CodecCommander.aml。2. 将 CodecCommander.kext 放入 CLOVER &gt; Kext### SSDT-Config.aml**作用：**用于配置 Hotpatch 其他补丁，例如 SSDT-PNLF.aml、SSDT-IGPU.aml 等都需要读取这 SSDT 里面的配置。**使用方法：**将本 SSDT 放入 EFI &gt; CLOVER &gt; ACPI &gt; Patches。**配置说明：** // configuration data for other SSDTs in this pack DefinitionBlock(“”, “SSDT”, 2, “hack”, “RMCF”, 0){ Device(RMCF) { Name(_ADR, 0) // do not remove Method(HELP) { Store(&quot;TYPE indicates type of the computer. 0: desktop, 1: laptop&quot;, Debug) Store(&quot;HIGH selects display type. 1: high resolution, 2: low resolution&quot;, Debug) Store(&quot;DPTS for laptops only. 1: enables/disables DGPU in _WAK/_PTS&quot;, Debug) Store(&quot;SHUT enables shutdown fix. 1: disables _PTS code when Arg0==5&quot;, Debug) Store(&quot;AUDL indicates audio layout-id for patched AppleHDA. Ones: no injection&quot;, Debug) Store(&quot;BKLT indicates the type of backlight control. 0: IntelBacklight, 1: AppleBacklight&quot;, Debug) Store(&quot;LMAX indicates max for IGPU PWM backlight. Ones: Use default, other values must match framebuffer&quot;, Debug) } // TYPE: Indicates the type of computer... desktop or laptop // // 0: desktop // 0: 台式机 // 1: laptop // 1: 笔记本 Name(TYPE, 1) // HIGH: High resolution/low resolution selection. Affects IGPU injection. // HIGH: 高分辨率/低分辨率选择。 影响IGPU注入。 // For 1600x900+ on Sandy/Ivy, use 1 // 对于1600x900 +在Sandy / Ivy，请使用1 // For UHD/QHD+ on Haswell/Broadwell, use 1 // 对于Haswell / Broadwell的UHD / QHD +，请使用1 // Others (low resolution), use 0 // 其他（低分辨率），使用0 Name(HIGH, 0) // DPTS: For laptops only: set to 1 if you want to enable and // DPTS：仅适用于笔记本电脑：如果要启用和，请设置为1 // disable the DGPU _PTS and _WAK. // 禁用DGPU _PTS和_WAK。 // 0: does not manipulate the DGPU in _WAK and _PTS // 0：不操作_WAK和_PTS中的DGPU // 1: disables the DGPU in _WAK and enables it in _PTS // 1：禁用_WAK中的DGPU，并在_PTS中启用它 Name(DPTS, 0) // SHUT: Shutdown fix, disable _PTS code when Arg0==5 (shutdown) // SHUT：关闭修复，当Arg0 == 5（关闭）时禁用_PTS代码， // 0: does not affect _PTS behavior during shutdown // 0：在关闭期间不影响_PTS行为 // 1: disables _PTS code during shutdown // 1：在关闭期间禁用_PTS代码 Name(SHUT, 0) // AUDL: Audio Layout // AUDL：音频布局 // The value here will be used to inject layout-id for HDEF and HDAU // 这里的值将用于注入HDEF和HDAU的layout-id // If set to Ones, no audio injection will be done. // 如果设置为Ones，则不会进行音频插入。 Name(AUDL, Ones) // BKLT: Backlight control type // BKLT：背光控制类型 // 0: Using IntelBacklight.kext // 0：使用IntelBacklight.kext // 1: Using AppleBacklight.kext + AppleBacklightInjector.kext // 1：使用AppleBacklight.kext + AppleBacklightInjector.kext Name(BKLT, 0) // LMAX: Backlight PWM MAX. Must match framebuffer in use. // LMAX：背光PWM最大值。 必须匹配使用中的帧缓冲区。 // Ones: Default will be used (0x710 for Ivy/Sandy, 0xad9 for Haswell/Broadwell) // Ones：将使用默认（Ivy / Sandy 的默认值是 0x710，Haswell / Broadwell 的默认值是 0xad9） // Other values: must match framebuffer // 其他值：必须与framebuffer相匹配 Name(LMAX, Ones) } }//EOF12345678910111213141516171819202122232425上面 RM 都注释了，我以 Google 翻译过来，方便理解。* 第一个值，**TYPE** 从 SSDT-IGPU 调用，影响显卡 ID 的注入。查看了下代码，好像是区分是否注入高分屏 ID 有关。* 第二个值，**HIGH** 从 SSDT-IGPU 调用，影响点卡 ID 的注入。当 TYPE 设置成笔记本才生效。* 第三个值，**DPTS** 从 SSDT-PTSWAK 调用，这个 SSDT 是重写了睡眠和唤醒的方法，加入了一些我们补丁需要用到的代码，这里设置 1 则会在睡眠的时候开启显卡，唤醒后关闭显卡。* 第四个值，**SHUT** 从 SSDT-PTSWAK 调用，这个 SSDT 功能同上，这里设置 1 则会在关机的时候禁用 _PTS，和 Shutdown fix 同理。* 第五个值，**AUDL** 从 SSDT-HDAU 和 SSDT-HDEF 调用，这两个 SSDT 前者负责注入声卡 ID，后者则负责注入 HDMI 声卡 ID，而这个值就是控制两个 SSDT 注入声卡的行为，如果写 Ones 则什么都不注入，如果写 3，则声卡的 layout-id 则为 3。* 第六个值，**BKLT** 从 SSDT-PNLF 调用，这个 SSDT 看名字大家应该都很熟悉，就是加入 PNLF 设备，用来启用我们的笔记本亮度调节驱动的，而这个值是控制亮度调节的驱动是用哪一种，0 是使用 IntelBacklight.kext，1 是使用 AppleBacklight.kext + AppleBacklightInjector.kext。* 第七个值，**LMAX** 从 SSDT-PNLF 调用，这个 SSDT 同上，这个值是设置背光的 PWM 最大值，Ones 是使用默认值，Ivy / Sandy 的默认值是 0x710，Haswell / Broadwell 的默认值是 0xad9，你也可以设置其他值，但是这个值必须与 framebuffer 相匹配。### SSDT-DAMD-VM510LI.aml**作用：**用于屏蔽 9CC3 芯片组的独立显卡（AMD 与 NVIDIA 通用）**使用方法：**1. 在 CLOVER 的 config.list &gt; ACPI &gt; DSDT &gt; Patches 添加以下补丁，并且 SortedOrder 加入 SSDT-DAMD-VM510LI.aml。2. EFI &gt; CLOVER &gt; ACPI &gt; Patches 放入本 SSDT。补丁1： Comment：change Method(SGOF,0,Serialized) to XGOF, optionally pair with SSDT-DAMD-VM510LI.amlFind：53474F46 08Replace：58474F46 08123补丁2： Comment：Comment:change Method(_REG,0,Serialized) to XREG, optionally pair with SSDT-DAMD-VM510LI.amlFind：5F524547 02Replace：58524547 021234567891011121314### SSDT-Fn-VM510LI.aml**作用：**配合 AsusNBFnKeys.kext 驱动使用，修改 _QE0 和 _QF0 方法而实现 FN 亮度调整功能。**使用方法：**1. 在 CLOVER 的 config.list &gt; ACPI &gt; DSDT &gt; Patches 添加以下补丁，并且 SortedOrder 加入 SSDT-Fn-VM510LI.aml。2. EFI &gt; CLOVER &gt; ACPI &gt; Patches 放入本 SSDT。补丁1： Comment：change _Q0E to XQ0E, optionally pair with SSDT-Fn.amlFind：5F513045Replace：58513045123补丁2： Comment：change _Q0F to XQ0F, optionally pair with SSDT-Fn.amlFind：5F513046Replace：585130461234567891011121314### SSDT-HDAU.aml 与 SSDT-HDEF.aml**作用：**注入音频 layout-id 使得声卡出声，需要配合 AppleALC.kext。**使用方法：**1. 在 CLOVER 的 config.list &gt; ACPI &gt; DSDT &gt; Patches 添加以下补丁，并且 SortedOrder 加入 SSDT-HDEF.aml 和 SSDT-HDEF.aml。2. EFI &gt; CLOVER &gt; ACPI &gt; Patches 放入本 SSDT。3. 修改 SSDT-Config.aml 的 AUDL 字段为所对应的 layout-id，9CC3 是 ALC233（ALC3236），最佳的 layout-id 是4，故此此值应当设置为4。补丁： Comment：change B0D3 to HDAU, optionally pair with SSDT-HDAU.amlFind：42304433Replace：484441551234567891011121314151617### SSDT-IGPU.aml**作用：**注入显卡 AAPL,snb-platform-id 驱动核心显卡。**使用方法：**1. 在 CLOVER 的 config.list &gt; ACPI &gt; DSDT &gt; Patches 添加以下补丁，并且 SortedOrder 加入 SSDT-IGPU.aml。2. EFI &gt; CLOVER &gt; ACPI &gt; Patches 放入本 SSDT。3. 修改 SSDT-Config.aml 的 TYPE 字段为 1。4. 如果是高分辨率（超过1080P）屏幕，请修改 SSDT-Config.aml 的 HIGH 字段为 1，其余分辨率为 0。补丁： Comment：change GFX0 to IGPU, optionally pair with SSDT-IGPU.amlFind：47465830Replace：494750551234567891011121314151617181920212223242526### SSDT-PNLF.aml**作用：**亮度调节补丁，本补丁支持两种驱动方式。（AppleBacklight.kext + AppleBacklightInjector.kext 或 IntelBacklight.kext） 目前使用的是 IntelBacklight.kext**使用方法：**1. 在 CLOVER 的 config.list &gt; ACPI &gt; SortedOrder 加入 SSDT-PNLF.aml。2. EFI &gt; CLOVER &gt; ACPI &gt; Patches 放入本 SSDT。### SSDT-PRW.aml**作用：**修复 USB 睡眠唤醒补丁。**使用方法：**1. 在 CLOVER 的 config.list &gt; ACPI &gt; DSDT &gt; Patches 添加以下补丁，并且 SortedOrder 加入 SSDT-PRW.aml。2. EFI &gt; CLOVER &gt; ACPI &gt; Patches 放入本 SSDT。补丁： Comment：change Method(GPRW,2,N) to XPRW, pair with SSDT-PRW.amlFind：47505257 02Replace：58505257 0212345678910111213141516171819202122232425262728293031323334353637### SSDT-SMBUS.aml**作用：**SMBUS fix 补丁。**使用方法：**1. 在 CLOVER 的 config.list &gt; ACPI &gt; SortedOrder 加入 SSDT-SMBUS.aml。2. EFI &gt; CLOVER &gt; ACPI &gt; Patches 放入本 SSDT。### SSDT-ssdtPRGen.aml**作用：**CPU I5 5200U 的 SSDT，用于加载 X86PlatformPlugin 的机型参数，使得加载原生电源管理。如果是其他 CPU，请自行使用 ssdtPRGen.sh 生成自己 CPU 的 SSDT，重命名为 SSDT-ssdtPRGen.aml 放入 EFI &gt; CLOVER &gt; ACPI &gt; Patches。**使用方法：**1. 在 CLOVER 的 config.list &gt; ACPI &gt; SortedOrder 加入 SSDT-ssdtPRGen.aml。2. EFI &gt; CLOVER &gt; ACPI &gt; Patches 放入本 SSDT。### SSDT-XOSI.aml**作用：**OS Check Fix**使用方法：**1. 在 CLOVER 的 config.list &gt; ACPI &gt; DSDT &gt; Patches 添加以下补丁，并且 SortedOrder 加入 SSDT-XOSI.aml。2. EFI &gt; CLOVER &gt; ACPI &gt; Patches 放入本 SSDT。补丁： Comment：change _OSI to XOSI, pair with SSDT-XOSI.amlFind：5F4F5349Replace：584F5349``` Kext 文件说明 驱动名称 版本号 用途 ACPIBatteryManager.kext 2016-1118 配合 SSDT-BATT-VM510LI 显示电量。 AppleALC.kext 1.0.19 驱动声卡，需配合 SSDT-HDAU.aml 与 SSDT-HDEF.aml 使用。 另注入 ID 需在 SSDT-Config.aml 的 AUDL 字段注入 layout-id，根据 9CC3 提取的 Codec 得出，最符合的 layout-id 是4。 ApplePS2SmartTouchPad.kext v4.7 beta 5 触摸板与键盘驱动 AsusNBFnKeys.kext v2.6 华硕专用 FN 驱动，需配合 SSDT-Fn-VM510LI.aml 使用。 CodecCommander.kext 2016-0721 修复睡眠唤醒后无声问题，修复耳机只有背景声问题。 IntelBacklight.kext 2017-0206 显示屏亮度驱动，需配合 SSDT-PNLF.aml 使用。 RealtekRTL8111.kext 2015-1230 有线网卡驱动 FakeSMC.kext and FakeSMC*.kext 2017-0117 黑苹果必备驱动 Clover 配置文件 Config.list 说明ACPIFixes AddDTGP_0001 （添加 DTGP 方法，修复 ACPI 出现的 DTGP 错误） FIX_ACST_4000000 （修复 ASUS 与 Apple 的电源管理寄存器命名冲突） FIX_RTC_20000 （RTC Fix 从RTC设备中排除IRQ（0）） FIX_S3D_2000000 （通过更正_S3D方法解决一些睡眠/唤醒问题。） FIX_WAK_200000 （同等于 DSDT Fix _WAK Arg0 v2 补丁） FixHPET_0010 （同等于 DSDT HPET Fix 补丁） FixIPIC_0040 （同等于 IRQ Fix 补丁） NewWay_80000000 （应用新补丁，Clover 从 4006 版本开始取消此选项。） Patches change _OSI to XOSI, pair with SSDT-XOSI.aml （配合 SSDT-XOSI 使用，同等于 OS Check Fix。） change EHC1 to EH01 （修复 USB 设备命名，使其更符合 Apple 规范。） change EHC2 to EH02 （同上） Rename _DSM to XDSM （修复开机关于 _DSM 五国问题。） change GFX0 to IGPU, optionally pair with SSDT-IGPU.aml （修改 GFX0 设备名称，更符合 Apple 规范，另配合 SSDT-IGPU.aml 注入显卡 ID，驱动显卡。） change Method(GPRW,2,N) to XPRW, pair with SSDT-PRW.aml （配合 SSDT-PRW.aml 修复 USB 唤醒问题，同等于 USB3 _PRW 0X0D（或0X6D）(instant wake）。） change B0D3 to HDAU, optionally pair with SSDT-HDAU.aml （配合 SSDT-HDAU.aml 与 SSDT-HDEF.aml 和 AppleALC.kext 驱动声卡。） change _Q0E to XQ0E, optionally pair with SSDT-Fn.aml （配合 SSDT-Fn.aml 与 AsusNBFnKeys.kext 使 FN f5 f6 的亮度调整按键生效。） change _Q0F to XQ0F, optionally pair with SSDT-Fn.aml （同上。） change Method(TACH,1,N) to XACH, optionally pair with SSDT-BATT-VM510LI.aml （配合 SSDT-BATT-VM510LI.aml 和 ACPIBatteryManager.kext 显示电量。） change Method(_BIX,0,N) to XBIX, optionally pair with SSDT-BATT-VM510LI.aml （同上。） change Method(BIFA,0,N) to XIFA, optionally pair with SSDT-BATT-VM510LI.aml（同上。） change Method(SMBR,3,N) to XMBR, optionally pair with SSDT-BATT-VM510LI.aml（同上。） change Method(ECSB,7,N) to XCSB, optionally pair with SSDT-BATT-VM510LI.aml（同上。） change Method(SMBW,5,N) to XMBW, optionally pair with SSDT-BATT-VM510LI.aml（同上。） change Method(SGOF,0,Serialized) to XGOF, optionally pair with SSDT-DAMD-VM510LI.aml （配合 SSDT-DAMD-VM510LI.aml 屏蔽独显。） Comment:change Method(_REG,0,Serialized) to XREG, optionally pair with SSDT-DAMD-VM510LI.aml （同上。） DropTables SSDT Cpc_Tabl （禁用主板提供的 cpuPR SSDT，换成我们使用 ssdtPRGen 生成的 ssdt。） DMAR KernelAndKextPatchesKextsToPatch AirPort Extreme （我更换了 BCM94352hmb 使用的补丁，9CC3 是 ar9565 的网卡，无需此补丁，我这里禁用了此补丁） AirPortBrcm4360 - fcvo, 10.12.x (credit the-darkvoid) （同上） 10.11-BCM94352-5GHz-US-FCC-dv （同上） TRIM function for non-Apple SSDs （为 SSDT 开启 TRIM） Boot graphics glitch, 10.12.dp1 （改善 10.12 开机撕裂苹果图标的补丁，只能加快撕裂的消失时间，并不能完全去掉。） Disable minStolenSize less or equal fStolenMemorySize assertion, 10.12.0 ( (based on Austere.J patch) （取消 10.12 限制 minStolenSize 的限制，9CC3 可以在 Bios 设置，故此我禁用此补丁。） HDMI-audio 0x16260006 （HDMI 音频补丁） change 15 port limit to 20 in AppleUSBXHCIPCI （15个 USB 端口限制补丁，9CC3 并没有超过15个，可不用此补丁，这里默认禁用） SMBIOS 机型选择 MacBookPro12,1 如果开机遇到 can’t perform kext scan: no kext summary 的五国，请勾上 Trust，默认是启用 Trust。 AR9565AR9565 蓝牙无解 驱动下载地址：9565.zip 作者发布下载地址：9565.zip 发布地址（需要翻墙）：Kext for wifi ar9565 for hackintosh macOS Sierra 10.12 (16A323) 使用说明： open terminal and write defaults write com.apple.finder AppleShowAllFiles YES killall Finder go to System/Library/Extensions and delete IO80211Family.kext and IO80211FamilyV2.kext open kext utility and install corecapture.kext and CoreCaptureResponder.kext open clover configurator and mount your efi partition go to EFI/CLOVER/kexts/10.12 and move IO80211Family.kext reboot enjoy My youtube channel https://www.youtube.com/channel/UCzxRc20c5_bC2zaBFQ4GFsQ Like and fap thanks for watching. 打开终端 执行 （显示隐藏文件）defaults write com.apple.finder AppleShowAllFiles YESkillall Finder 删除S/L/E内的 IO80211Family.kext和IO80211FamilyV2.kext 使用kext utility 安装 corecapture.kext 和 CoreCaptureResponder.kext 把IO80211Family.kext放到EFI/CLOVER/kexts/10.12 重启 解决 ALC233 唤醒无声及带麦克风耳机只有背景声请看此贴 关于耳机只有背景声及唤醒无声的探讨【更新ALC233解决方案】 已知问题 二合一耳机麦克风无输入。 SD 读卡器 ID 为 0x0129 无解。 亮度无法保存。 VGA 无输出。 ASUS W519LI 电量无法显示，暂时未知什么问题导致。 #2017年03月09日10:24:06 高分屏如 ASUS FL5800L 更换 UHD 目录下的 SSDT-Config.aml 文件（HIGH 字段改成1）。 突破高分屏限制开启内屏请参考 驱动显卡后4k屏幕点不亮的问题]]></content>
      <categories>
        <category>黑苹果</category>
      </categories>
      <tags>
        <tag>黑苹果</tag>
        <tag>Mac</tag>
        <tag>Hackintosh</tag>
        <tag>ASUS</tag>
        <tag>VM510LI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BCM94252HMB 国家地区代码修改]]></title>
    <url>%2F2017%2F03%2F07%2FBCM94352-5GHz-CN%2F</url>
    <content type="text"><![CDATA[我们常用的 5G 频道补丁 123Name：AirPortBrccom.apple.driver.AirPort.Brcm4360m4360Find：4183FCFF742C48Replace：66C7065553EB2B 其中修改的 55 53 就是 US 的意思. 那么修改成 CN 就是 43 4E 1234neros-MBP:~ nero$ echo -n CN |xxd00000000: 434e CNneros-MBP:~ nero$ echo -n US |xxd00000000: 5553 US 故此,我们将补丁修改为 1234Name：AirPortBrccom.apple.driver.AirPort.Brcm4360m4360Find：4183FCFF742C48Replace：66C706434EEB2BComment10.11-BCM94352-5GHz-CN-dv 出处 https://www.tonymacx86.com/threads/guide-airport-pcie-half-mini-v2.104850/page-209#post-1350761 2017年03月12日 更新 将代码改成 #a 可以开启所有频段，自适应所有国家代码。 1234Name：com.apple.driver.AirPort.Brcm4360Find：4183fcff 742c48Replace：66c70623 61eb2bComment：10.11-BCM94352-5GHz-#a-dv 另 Name 最好写com.apple.driver.AirPort.Brcm4360，不要写 AirPortBrcm4360，因为这样 Kext to Patch 会寻找所有包含 AirPortBrcm4360 的 Kext 都修补一次。]]></content>
      <categories>
        <category>黑苹果</category>
      </categories>
      <tags>
        <tag>黑苹果</tag>
        <tag>Mac</tag>
        <tag>Hackintosh</tag>
        <tag>ASUS</tag>
        <tag>VM510LI</tag>
        <tag>BCM94252HMB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACPI 一些备忘]]></title>
    <url>%2F2017%2F02%2F26%2FACPI-Memo%2F</url>
    <content type="text"><![CDATA[有时候查看 ACPI 时候，为了熟悉他的逻辑，需要学习一些 ACPI 语法，这里是关于 ACPI 语法的备忘录。 本备忘均从 《Advanced Configuration and Power Interface Specification》 查阅，并使用 Google 翻译得来，本人英语极渣故此不确保翻译准确，如有需要请查阅原版文档。 运算符LEqual（逻辑等）语法LEqual（Source1，Source2）=&gt; Boolean Source1 == Source2 =&gt; Boolean 参数Source1和Source2必须各自求值为整数，字符串或缓冲区。 Source1的数据类型指示所需的Source2类型。 如果需要匹配Source1的类型，则会隐式转换Source2。 描述如果值相等，则返回True; 否则返回False。 对于整数，执行数字比较。 对于字符串和缓冲区，只有当两个长度相同并且逐字节比较的结果表明完全相等时才返回True。 LOr（逻辑或）语法LOr（Source1，Source2）=&gt; Boolean Source1 || Source2 =&gt; Boolean 参数Source1和Source2被计算为整数。 描述如果任一值不为零，则返回True; 否则返回False。 Decrement (整数递减)语法Decrement (Minuend) =&gt; Integer Minuend-- =&gt; Integer 参数Minuend应该为一个整数。 描述此操作将Minuend减1，并将结果存储回Minuend。 等效于 Subtract（Minuend，1，Minuend）。 下溢条件被忽略，结果为Ones。 功能Sleep （毫秒级 Sleep）语法Sleep (数值 毫秒) 参数Sleep项用于实现长期定时要求。 执行被延迟至少所需的毫秒数。 描述睡眠的实现是将请求舍入直到由OS支持的最接近的睡眠时间并放弃处理器。（The implementation of Sleep is to round the request up to the closest sleep time supported by the OS and relinquish the processor.） 以上我猜测：使用此方法可以将该设备进入休眠状态（切断电源） Stall (短时间停止)语法Stall (微秒=10^6 秒) 参数Stall项用于实现短期时序要求。 执行被延迟至少所需的微秒数。 描述Stall的实现是特定于OS的，但不能放弃对处理器的控制。 因此，超过100微秒的延迟必须使用Sleep而不是Stall。 系统保留方法_INI （init）_INI是执行设备特定初始化的设备初始化对象。 此控制方法位于设备对象下，并且仅当OSPM加载描述表时运行。 有一些限制，当这个方法被调用和管理写这个方法的代码。 _INI方法只能访问已被指示为可用的操作区域，由_REG方法定义。 _REG方法在第6.5.4节“_REG（Region）”中描述。此控制方法在运行_ADR，_CID，_HID，_SUN和_UID之前运行。 返回值：没有 在评估_INI对象之前，OSPM评估设备的_STA对象。如果设备不存在_STA对象，则假定设备既存在又起作用。如果_STA方法指示设备存在，OSPM将评估设备的_INI（如果存在_INI方法），并将检查_INI方法的设备的每个子项。如果_STA方法指示设备不存在并且不起作用，则OSPM将不运行_INI，并且不会检查设备的_INI方法的子代。如果_STA对象评估指示设备不存在但是功能正常，OSPM将不会评估_INI对象，但会检查设备的每个子对象的_INI对象（有关此特殊情况的说明，请参阅_STA的说明） 。）如果在表已经加载后设备出现，OSPM将不会评估_INI方法，也不会检查_INI方法的子项。 OSPM根据_STA Present和Functional位执行_INI对象操作，总结在下表中。 Table 6-223 OSPM _INI Object Actions _STA Present Bit _STA 功能Bit 操作 0 0 不要运行_INI，不要检查设备的子项。 0 1 不要运行_INI，检查设备的子项。 1 0 运行_INI，检查设备子项。 1 1 运行_INI，检查设备子项。 _INI控制方法通常用于将设备切换到传统操作模式。 例如，平台引导固件通常将旧式模式下的CardBus控制器配置为支持传统操作系统。 在使用ACPI操作系统枚举设备之前，必须将CardBus控制器初始化为CardBus模式。 对于这样的系统，供应商可以在CardBus控制器下包括_INI控制方法以将设备切换到CardBus模式。 除了设备初始化之外，OSPM在命名空间初始化的开始时无条件地评估\ _SB命名空间下的_INI对象（如果存在）。 _REG(Region)OS运行_REG控制方法以通知AML代码操作区域的可用性的改变。当操作区域处理程序不可用时，AML无法访问该区域中的数据字段。 （操作区域写入将被忽略，读取将返回不确定的数据。） 参数：（2） Arg0 - 包含操作区域地址空间ID的整数 Arg1 - 包含处理程序连接代码的整数 0 - 断开处理程序1 - 连接处理程序 返回值：没有 除了下面所示的情况，控制方法必须假设所有操作区域都不可访问，直到执行_REG（RegionSpace，1）方法。一旦对特定操作区域执行了_REG，指示操作区域处理程序就绪，则控制方法可以访问操作区域中的字段。相反，当_REG方法执行未指示操作区域处理程序就绪时，控制方法不得访问操作区域中的字段。 例如，在嵌入式控制器驱动程序就绪之前，控制方法无法访问嵌入式控制器。一旦OSPM运行_REG（EmbeddedControl，1），控制方法就可以访问嵌入式控制器地址空间中的操作区域。此外，如果OSPM执行_REG（EmbeddedControl，0），控制方法必须停止访问嵌入式控制器地址空间中的操作区域。 此规则的例外情况如下： OSPM必须保证以下操作区域始终可访问： 包含_BBN对象的PCI根总线上的PCI_Config操作区域。 SystemIO操作区域。 访问系统地址映射报告接口返回的内存时的SystemMemory操作区域。 OSPM必须通过ECDT中描述的嵌入式控制器访问嵌入式控制器操作区域，然后才能执行任何控制方法。 在OSPM运行_REG（EmbeddedControl，0）后，这些操作区域可能无法访问。将_REG放置在与操作区域声明相同的范围中。 当在该范围中声明的操作区域可供使用时，OS将在给定范围中运行_REG。 Example: 123Scope(\_SB.PCI0) &#123; OperationRegion(OPR1, PCI_Config, ...) Method(_REG, 2) &#123;...&#125; // OSPM在PCIO操作区域处理程序时执行此操作 // 状态更改 Device(PCI1) &#123; Method(2) &#123;...&#125; Device(ETH0) &#123; OperationRegion(OPR2, PCI_Config, ...) Method(_REG,2) &#123;...&#125; &#125; &#125; Device(ISA0) &#123; OperationRegion(OPR3, SystemIO, ...) Method(_REG, 2) &#123;...&#125; // OSPM在ISAO操作区域处理程序时执行此操作 // 状态更改 Device(EC0) &#123; Name(_HID, EISAID(&quot;PNP0C09&quot;)) OperationRegion(OPR4, EmbeddedControl, ...) Method(_REG, 2) &#123;...&#125; // OSPM在EC操作区域执行此操作 &#125; &#125; &#125; 当PCI0操作区域处理程序就绪时，OSPM将运行在PCI0范围中声明的_REG方法，以指示PCI0空间操作区域访问在PCI0范围内可用（换句话说，允许OPR1访问）。 当ISA0操作处理程序就绪时，OSPM将在ISA0作用域中运行_REG方法，以指示I / O空间操作区域访问在该范围内可用（换句话说，允许OPR3访问）。 最后，当嵌入式控制器操作区域处理程序就绪时，OSPM将在EC0作用域中运行_REG方法，以指示EC空间操作区域访问在EC0范围内可用（换句话说，允许OPR4访问）。 应当注意，一旦主控制器或桥控制器已经用总线编号编程，则PCI配置空间操作区就准备就绪。 PCI1的_REG方法将不会运行，直到PCI-PCI桥已正确配置。同时，操作系统也将运行ETH0的_REG方法，因为它的PCI配置空间也可用。当ETH0设备启动时，OS将再次运行ETH0的_REG方法。此外，当主机控制器或桥控制器被关闭或禁用时，子设备的PCI配置空间操作区域不再​​可用。因此，ETH0的_REG方法将在关闭时运行，并在PCI1关闭时再次运行。 注意：操作系统只运行与使用刚刚可用的操作区域类型的操作区域声明出现在相同范围内的_REG方法。 例如，当加载PCI总线驱动程序时，EC设备中的_REG不会运行，因为在EC下声明的操作区域不使用PCI驱动程序提供的任何操作区域类型（即配置空间，I / O ，和存储器）。]]></content>
      <categories>
        <category>黑苹果</category>
      </categories>
      <tags>
        <tag>黑苹果</tag>
        <tag>Mac</tag>
        <tag>Hackintosh</tag>
        <tag>ASUS</tag>
        <tag>ACPI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华硕 VM510LI Hotpatch]]></title>
    <url>%2F2017%2F02%2F25%2FHotpatch%2F</url>
    <content type="text"><![CDATA[本笔记参考 RehabMan 指南 [Guide] Using Clover to “hotpatch” ACPI [TOC] Hotpatch 简述什么是 Hotpatch? RehabMan 的介绍是: That guide uses what is known as “static patching”. In order to inject patched ACPI files, we extract native ACPI, disassemble them, make changes, then recompile and place the files in ACPI/patched, so that Clover injects the patched ACPI instead of native ACPI. With the techniques detailed in this guide, the changes can be made directly to the ACPI binaries provided by BIOS, skipping the extract, disassembly, and recompilation steps. 该指南使用所谓的“静态修补”。 为了注入修补的ACPI文件，我们提取本地ACPI，反汇编，进行更改，然后重新编译并将文件放在ACPI / patched中，以便Clover注入修补的ACPI而不是本机ACPI。 使用本指南中详述的技术，可以直接对BIOS提供的ACPI二进制文件进行更改，跳过提取，反汇编和重新编译步骤。(翻译来自 Google 翻译) 我的理解: 其实 Hotpatch 就是将所有修补 ACPI 文件的补丁变成一个一个模块,通过重命名主板提供的 ACPI 文件原来的 Method (方法/函数) 来禁用原有的方法,再用 SSDT 来放入我们修改后的(已修补)的 Method (方法/函数). 当然上面所说的是终极解决的办法,其实还有很多很简单的方法能够完成 ACPI 补丁的功能. 如果有兴趣可以去看看 RahabMan 帖子. 之前我在 DSDT 打的补丁有. 12345678910&quot;Fix _WAK Arg0 v2&quot; &quot;HPET Fix&quot; &quot;SMBUS Fix&quot;&quot;IRQ Fix&quot; &quot;RTC Fix&quot; &quot;OS Check Fix（Windows 7）&quot; &quot;OS Check Fix（Windows 8）&quot; &quot;Fix Mutex with non-zero SyncLevel&quot; //对比了下 这个补丁是不需要打的&quot;Rename GFX0 to IGPU&quot; &quot;Brightness fix(Haswell/Broadwell)&quot; Clover 常规补丁 Fix _WAK Arg0 v2 → ACPI &gt; DSDT &gt; FIX_WAK_200000 IRQ Fix 和 HPET Fix → ACPI &gt; DSDT &gt; FixHPET_0010 和 ACPI &gt; DSDT &gt; FixIPIC_0040 RTC Fix → ACPI &gt; DSDT &gt; FIX_RTC_20000 OS Check Fix（Windows 7）和 OS Check Fix（Windows 8）HotPatch 的方式是,将调用 _OSI 的方法重命名为 XOSI. 然后再放入 SSDT-XOSI.aml 到 Clover &gt; ACPI &gt; Patched 123Comment: Change _OSI to XOSIFind: &lt;5f4f 5349&gt;Replace: &lt;584f 5349&gt; 意思就是,将调用 _OSI 方法的地方都改成调用 XOSI,而 XOSI 方法则是从 SSDT-XOSI.aml 引入的,我们再从 XOSI 方法修补. Rename GFX0 to IGPU和上面重命名方法一样 123Comment: Rename GFX0 to IGPUFind: &lt;4746 5830&gt;Replace: &lt;4947 5055&gt; Brightness fix(Haswell/Broadwell)这个补丁方法 GFX 重命名为 IGPU,上一节补丁已经应用了. 放入 SSDT-PNLF.aml SSDT-Config.aml 需要定义 BKLT 的值为 0. USB3_PRW 0X6D(instant wake)这个补丁方法,的方法遇上面的不太一样. 补丁片段 1234567891011# some _PRW have three entries in the Package into device name_adr 0x001D0000 code_regex Name.*_PRW.*\n.*\n.*\n.*\n.*\n.*\&#125;\) remove_matched;# 找到设备名称地址 0x001D0000 然后移除该设备的 _PRW 方法.# seems to work better if _PRW is present, but returns 0 (original was 3) for sleep stateinto device name_adr 0x001D0000 insert begin Name(_PRW, Package() &#123; 0x6D, 0 &#125;) end;# 找到设备名称地址 0x001D0000 输入变量名 _PRW 变量内容 &#123; 0x6D, 0 &#125;PS: 以上纯属猜测,本人未学习过 IASL 的编程语法,全靠蒙,如果错了请指正. 这样修改后,USB 总线 EHC1和 EHC2 设备中没有了 _PRW 方法了,直接变成了 _PRW 变量. 至于为何需要这样改,我并不清楚,这必须了解 USB 导致睡眠唤醒的代码原理,我看不懂.但是看补丁的修改方法还是会的. 那么将上面的补丁换成 Hotpatch 应该如何表现呢? 搜索了下, DSDT 中还有非常多的 _PRW 方法,他们遍布了整个 DSDT 的各种设备,如果还是使用简单的改名是不可靠的. 因为 Clover 的 Patches 是搜索 DSDT 的二进制版本进行修补,二进制中无法识别整个_PRW 方法是否属于 USB 设备下的,也就是是否属于 EHC1 EHC2 的设备,那么是否就没办法用 Hotpatch 方法来修补这个问题呢? 我们来看看被补丁修补的源代码是什么样的 下面是 EHC1 的 _PRW 方法 1234Method (_PRW, 0, NotSerialized) // _PRW: Power Resources for Wake&#123; Return (GPRW (0x6D, 0x03))&#125; 下面是 EHC2 的 _PRW 方法 1234Method (_PRW, 0, NotSerialized) // _PRW: Power Resources for Wake&#123; Return (GPRW (0x6D, 0x03))&#125; 下面是 XHC 的 _PRW 方法 1234Method (_PRW, 0, NotSerialized) // _PRW: Power Resources for Wake&#123; Return (GPRW (0x6D, 0x03))&#125; 我们可以发现我们补丁修改的每个 _PRW 方法都会调用一个方法 GPRW,并且调用 GPRW 方法的变量内容都是 0X6D. 再看看 RehabMan 写的 SSDT-PRW.dsl 内容 1234567891011121314151617181920212223242526// For solving instant wake by hooking GPRW or UPRWDefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;PRW&quot;, 0)&#123; External(XPRW, MethodObj) // In DSDT, native GPRW is renamed to XPRW with Clover binpatch. // (or UPRW to XPRW) // As a result, calls to GPRW (or UPRW) land here. // The purpose of this implementation is to avoid &quot;instant wake&quot; // by returning 0 in the second position (sleep state supported) // of the return package. Method(GPRW, 2) &#123; If (0x6d == Arg0) &#123; Return (Package() &#123; 0x6d, 0, &#125;) &#125; //检查第一个变量是否为 0X6D 如果结果为真,返回 &#123; 0x6d, 0, &#125; If (0x0d == Arg0) &#123; Return (Package() &#123; 0x0d, 0, &#125;) &#125; //检查第一个变量是否是 0X0D 如果结果为真,返回 &#123; 0x0d, 0, &#125; Return (XPRW(Arg0, Arg1)) //如果上述都不对,则转跳到 XPRW方法 (函数为转跳过来的值) &#125; Method(UPRW, 2) &#123; If (0x6d == Arg0) &#123; Return (Package() &#123; 0x6d, 0, &#125;) &#125; If (0x0d == Arg0) &#123; Return (Package() &#123; 0x0d, 0, &#125;) &#125; Return (XPRW(Arg0, Arg1)) &#125;&#125;//EOF 上面的逻辑很清晰了, 其实就是要将我们需要改的地方,直接用代码发回我们希望他得到的变量,那么我们就不必想如何识别哪些是 USB 的 _PRW 方法了. Hotpatch 我觉得就是,复杂的逻辑交给 ASL 代码来解决, Clover 的 Patch 只需要修改源代码的调用即可. 那么上面多了个 XPRW 是什么东东?为啥其余调用 GPRW 方法都调用他呢? 这个就是 Clover 需要做的,我要将所有原来调用 GPRW 方法的都调用到这个 SSDT-PRW 来,原来的 GPRW 我们更名为 XPRW. 明白了吧?所有代码都经过上面的逻辑,最终跑回被我们更名为 XPRW 的方法(也就是原来的GPRW 方法). 故此应用这个 SSDT 之前,我们需要将 DSDT 原来的 GPRW 方法重命名为 XPRW 方法 但是由遇到了一个问题,如何定位 GPRW 方法在二进制文件 aml 中的位置呢? 小笔记: aml 是 ASL 编程语言编译后的二进制文件,但是我们一般反编译或者 Patch都是讨论十六进制,因为每8个二进制代表一个字符 RehabMan 在 [Guide] Using Clover to “hotpatch” ACPI Rename and Replace 章节有讲到这个问题 大概的意思就是因为不同主板可能情况不同,我们需要使用 Hex Fiend 这样的软件来验证 GPRW 方法的十六进制代码. 方法就是用 Hex Fiend 打开 DSDT 的 aml 文件,然后搜索 GPRW, 你会看到有很多 GPRW, 我的 GPRW 方法在 DSDT 的最下面,所以我直接拉到最下面反向搜索. 最终找到以下十六进制代码 147 50 52 57 02 GPRW 再看看 GPRW 的十六进制代码是怎么样的? 12neros-MBP:test nero$ echo -n GPRW|xxd00000000: 4750 5257 GPRW 奇怪了,为何我在上面列举的代码多了一个 02 ? 我们看看原来 GPRW 方法源代码 12345678910111213141516171819Method (GPRW, 2, NotSerialized)&#123; Store (Arg0, Index (PRWP, Zero)) Store (ShiftLeft (SS1, One), Local0) Or (Local0, ShiftLeft (SS2, 0x02), Local0) Or (Local0, ShiftLeft (SS3, 0x03), Local0) Or (Local0, ShiftLeft (SS4, 0x04), Local0) If (And (ShiftLeft (One, Arg1), Local0)) &#123; Store (Arg1, Index (PRWP, One)) &#125; Else &#123; ShiftRight (Local0, One, Local0) FindSetLeftBit (Local0, Index (PRWP, One)) &#125; Return (PRWP)&#125; 看到了吧,方法名称紧挨着就是2,这个2就是 02. 发现下面的方法好像并不是所有都这样,需要验证. 根据上述帖子内容,aml 编译后会留下一个位置符来定义这个前面这个字符到底是方法,还是变量,还是设备. 根据我观察所得,(不同的 ASL 版本或者不同电脑获得的位置符号未必相同) ~~1234567891011Method 位置符号是 06 [xx xx xx xx]Name 位置符号是 08 [xx xx xx xx]```~~~~搜索 `06 47 50 52 57`~~~~一样可以定位到 GPRW 方法上,而且这个代码是唯一的,因为整个 DSDT 里面只有一个 GPRW 函数.~~**翻看 RM 的帖子,再验证了下,发现一个更好的规律和方法**将我们的 DSDT.dsl 文件使用如下命令编译. iasl -l DSDT.dsl1234567891011它会产生两个文件* DSDT.aml 编译后文件* DSDT.lst 混合列表文件用文字编辑软件打开 DSDT.lst, 会发现机械码和 iASL 代码混合在一齐,这个就是一个翻译文件一样,列举了各种代码的机械码模式,这样我们就可以更好的找到我们需要打补丁的代码原来是怎么样的.例如:我们需要将 `Method (TACH,1` 的方法重命名为 `Method(XACH,1` 来使得 TACH 方法失效,再注入 SSDT 中写入 TACH 方法,来代替它.那么我只需要搜索 **Method (TACH,1** 就能找到他机械码的模样. 22490: } 22492: Method (TACH, 1, Serialized) 00015565: 14 40 06 54 41 43 48 09 “.@.TACH.”12那么我们补丁就可以这样写 Find:14 40 06 54 41 43 48 09Replace:14 40 06 58 41 43 48 0912将我们字符转换成 Hex 形式可以用如下命令 neros-MBP:~ nero$ echo -n TACH |xxd00000000: 5441 4348 TACHneros-MBP:~ nero$ echo -n XACH |xxd00000000: 5841 4348 XACH1234567891011121314151617**小结**说了那么多,这个 USB3_PRW 0X6D(instant wake) 唤醒补丁的 Hotpatch 的方法就是1. 将 DSDT 的 GPRW 方法重命名为 XPRW2. 放入 RehabMan 写的 SSDT-PRW.aml 到 Clover &gt; ACPI &gt; patch **PS: 后来测试发现开机的时候系统日志会提示没有找到 UPRW ,这个是因为 SSDT-PRW.aml 包含了 UPRW 这个方法,而这个方法对我来说是没用的,故此放入 SSDT-PRW.aml 后如果不想出现 ACPI Error 的话,最好确认下自己的唤醒是调用 GPRW 还是 UPRW,然后将另一个方法注释掉.**## SMBUS Fix这个补丁就是在 SBUS 加入 BUS0 设备,只需要放入 SSDT-SMBUS.aml 即可.## Rename B0D3 to HDAU先将 B0D3 重命名为 HDAU Comment: change B0D3 to HDAU, optionally pair with SSDT-HDAU.amlFind: 42304433Replace: 4844415512345678910111213141516171819202122232425262728293031323334再放入 SSDT-HDAU.aml**注意修改 layout-id 的值为你声卡的 layout-id 值,我声卡的 layout-id 是4**```iASL// Automatic injection of HDAU properties// Note: Only for Haswell and BroadwellDefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;HDAU&quot;, 0)&#123; External(_SB.PCI0.HDAU, DeviceObj) External(RMCF.AUDL, IntObj) // inject properties for audio Method(_SB.PCI0.HDAU._DSM, 4) &#123; If (CondRefOf(\RMCF.AUDL)) &#123; If (Ones == \RMCF.AUDL) &#123; Return(0) &#125; &#125; If (!Arg2) &#123; Return (Buffer() &#123; 0x03 &#125; ) &#125; Local0 = Package() &#123; &quot;layout-id&quot;, Buffer(4) &#123; 4, 0, 0, 0 &#125;, //需要注意修改此 layout-id 值 &quot;hda-gfx&quot;, Buffer() &#123; &quot;onboard-1&quot; &#125;, &#125; If (CondRefOf(\RMCF.AUDL)) &#123; CreateDWordField(DerefOf(Local0[1]), 0, AUDL) AUDL = \RMCF.AUDL &#125; Return(Local0) &#125;&#125;//EOF ApplePS2SmartTouchPad 驱动的 Fn 按键补丁这个补丁需要打上 Fn 功能键才能调整亮度,我们先看看补丁都干了些什么 123456789101112131415161718# Patch by EMlyDinEsH (OSXLatitude)# Enables Fn brightness keys to work with my kext AsusNBFnKeys# Replacing method _Q0E with code for Brightness down key to workinto Method label _Q0E replace_content begin If (ATKP)\n &#123;\n ^^^^ATKD.IANE (0x20)\n &#125;end;# Replacing method _Q0F with code for Brightness up key to workinto Method label _Q0F replace_content begin If (ATKP)\n &#123;\n ^^^^ATKD.IANE (0x10)\n &#125;end; 上面这个补丁是将 _Q0E 方法和 _Q0F 方法的内容替换如下 12345678910111213141516171819Method (_Q0E, 0, NotSerialized) // _Qxx: EC Query&#123; If (ATKP) &#123; ^^^^ATKD.IANE (0x20) &#125;&#125;Method (_Q0F, 0, NotSerialized) // _Qxx: EC Query&#123; If (ATKP) &#123; ^^^^ATKD.IANE (0x10) &#125;&#125; 参考章节 USB3_PRW 0X6D(instant wake) 的方法. 重命名 _Q0E 方法和 _Q0F 方法为 XQ0E 和 XQ0F,使原先的方法失效. 再放入我们自己定义的 _Q0E 方法和 _Q0F 方法. 替换 _Q0E 和 _Q0F 方法名称命令行查找下以上两个方法的十六进制代码 12345678neros-MacBook-Pro:hotpatch nero$ echo -n _Q0E | xxd 00000000: 5f51 3045 _Q0Eneros-MacBook-Pro:hotpatch nero$ echo -n XQ0E | xxd 00000000: 5851 3045 XQ0Eneros-MacBook-Pro:hotpatch nero$ echo -n _Q0F | xxd 00000000: 5f51 3046 _Q0Fneros-MacBook-Pro:hotpatch nero$ echo -n XQ0F | xxd 00000000: 5851 3046 XQ0F 那么在 Clover 配置文件 ACPI &gt; DSDT &gt; Patches 写入如下补丁 123456789#补丁-1Comment: change _Q0E to XQ0E, optionally pair with SSDT-Fn.amlFind: 5f51 3045Replace: 5851 3045#补丁-2Comment: change _Q0F to XQ0F, optionally pair with SSDT-Fn.amlFind: 5f51 3046Replace: 5851 3046 如果觉得不放心,可以用 Hex Fiend 打开 DSDT.aml 文件来搜索替换一下,之后再用 iasl 来反编译,再用 MaciASL dsl 文件看看,是否已经被重命名为 XQ0E 和 XQ0F 重定义新的 _Q0E 和 _Q0F 方法我不会编写 SSDT, 但是我会抄~ 复制一份 SSDT-PRW.dsl 下来重命名为 SSDT-FN.dsl 用 MaciASL 打开. 将其修改为如下代码 1234567891011121314151617181920212223242526272829303132333435//Enables Fn brightness keys to work with my kext AsusNBFnKeysDefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;Fn&quot;, 0)&#123; // In DSDT, native _Q0E and _Q0F is renamed to XQ0E and XQ0F with Clover binpatch. // (or UPRW to XPRW) // As a result, calls to _Q0E and _Q0F land here. External(ATKP, IntObj) External(\_SB.ATKD.IANE, MethodObj) External(\_SB.PCI0.LPCB.EC0, DeviceObj) Scope(\_SB.PCI0.LPCB.EC0) &#123; Method (_Q0E, 0, NotSerialized) // _Qxx: EC Query &#123; If (ATKP) &#123; \_SB.ATKD.IANE (0x20) &#125; &#125; Method (_Q0F, 0, NotSerialized) // _Qxx: EC Query &#123; If (ATKP) &#123; \_SB.ATKD.IANE (0x10) &#125; &#125; &#125;&#125;//EOF PS:以上代码纯属乱搞,如果能用,纯属巧合哈~ 最终将此 SSDT-FN.dsl 编译成 aml, 再放入 Clover &gt; ACPI &gt; patches 电池补丁方法分析根据远景论坛的教学贴,我学会了编写自己笔记本的电池电量补丁. 以下是我 华硕 VM510LI 的电量补丁 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#Maintained by: Nero for: Laptop Patches#battery_ASUS-VM510LI.txt# created by Nero 1/2017#Create B1B2 Methodinto method label B1B2 remove_entry;into definitionblock code_regex . insertbeginMethod (B1B2, 2, NotSerialized)\n&#123;\nReturn(Or(Arg0, ShiftLeft(Arg1, 8)))\n&#125;\nend;# utility methods to read/write buffers from/to ECinto method label RE1B parent_label EC0 remove_entry;into method label RECB parent_label EC0 remove_entry;into device label EC0 insertbeginMethod (RE1B, 1, NotSerialized)\n&#123;\n OperationRegion(ERAM, EmbeddedControl, Arg0, 1)\n Field(ERAM, ByteAcc, NoLock, Preserve) &#123; BYTE, 8 &#125;\n Return(BYTE)\n&#125;\nMethod (RECB, 2, Serialized)\n&#123;\n ShiftRight(Arg1, 3, Arg1)\n Name(TEMP, Buffer(Arg1) &#123; &#125;)\n Add(Arg0, Arg1, Arg1)\n Store(0, Local0)\n While (LLess(Arg0, Arg1))\n &#123;\n Store(RE1B(Arg0), Index(TEMP, Local0))\n Increment(Arg0)\n Increment(Local0)\n &#125;\n Return(TEMP)\n&#125;\nend;# utility method to write to EC buffersinto method label WE1B parent_label EC0 remove_entry;into method label WECB parent_label EC0 remove_entry;into device label EC0 insertbeginMethod (WE1B, 2, NotSerialized)\n&#123;\n OperationRegion(ERAM, EmbeddedControl, Arg0, 1)\n Field(ERAM, ByteAcc, NoLock, Preserve) &#123; BYTE, 8 &#125;\n Store(Arg1, BYTE)\n&#125;\nMethod (WECB, 3, Serialized)\n&#123;\n ShiftRight(Arg1, 3, Arg1)\n Name(TEMP, Buffer(Arg1) &#123; &#125;)\n Store(Arg2, TEMP)\n Add(Arg0, Arg1, Arg1)\n Store(0, Local0)\n While (LLess(Arg0, Arg1))\n &#123;\n WE1B(Arg0, DerefOf(Index(TEMP, Local0)))\n Increment(Arg0)\n Increment(Local0)\n &#125;\n&#125;\nend;#Convert 16 bit to 8 bit registersinto device label EC0 code_regex TAH0,\s+16, replace_matched begin TA00,8,TA01,8, end;into device label EC0 code_regex TAH1,\s+16, replace_matched begin TA20,8,TA21,8, end;into device label EC0 code_regex B0C3,\s+16, replace_matched begin B001,8,B002,8, end;into device label EC0 code_regex B0SN,\s+16, replace_matched begin B0S0,8,B0S1,8, end;into device label EC0 code_regex B1SN,\s+16 replace_matched begin B1S0,8,B1S1,8 end;into device label EC0 code_regex DT2B,\s+16 replace_matched begin DT01,8,DT02,8 end;#Fix 16 bit registersinto method label TACH code_regex \(TAH0, replaceall_matched begin (B1B2(TA00,TA01), end;into method label TACH code_regex \(TAH1, replaceall_matched begin (B1B2(TA20,TA21), end;into method label _BIX code_regex \^\^LPCB.EC0.B0C3, replaceall_matched begin B1B2(^^LPCB.EC0.B001,^^LPCB.EC0.B002), end;into method label BIFA code_regex \(B0SN, replaceall_matched begin (B1B2(B0S0,B0S1), end;into method label BIFA code_regex \(B1SN, replaceall_matched begin (B1B2(B1S0,B1S1), end;into method label SMBR code_regex \(DT2B, replaceall_matched begin (B1B2(DT01,DT02), end;into method label SMBW code_regex Store\s\(Arg4,\sDT2B\) replaceall_matched begin Store (ShiftRight(Arg4,8),DT02)\nStore (Arg4,DT01) end;#fix 256 bit registersinto method label SMBR code_regex Store\s+\((.*),\s+BDAT\) replaceall_matched begin WECB(0x1c,256,%1) end;into method label SMBW code_regex Store\s+\((.*),\s+BDAT\) replaceall_matched begin WECB(0x1c,256,%1) end;into method label ECSB code_regex Store\s+\((.*),\s+BDAT\) replaceall_matched begin WECB(0x1c,256,%1) end;into method label ECSB code_regex Store\s+\((.*),\s+BDA2\) replaceall_matched begin WECB(0x44,256,%1) end;into method label ECSB code_regex \(BDAT, replaceall_matched begin (RECB(0x1c,256), end;into method label ECSB code_regex \(BDA2, replaceall_matched begin (RECB(0x44,256), end;into method label SMBR code_regex \(BDAT, replaceall_matched begin (RECB(0x1c,256), end; 大家都知道电量修补是一项非常复杂的修改,需要将调用到的变量高于8位的数值拆分成8位来处理. 故此修改代码量非常多,并且变量名称均需要重命名及重新赋值. Hotpatch 因为是注入 SSDT 来实现补丁效果,故此我们需要找到补丁修改的各个变量赋值与函数调用的变量. RM 教给大家一个办法,先将 DSDT.dsl 打上电池补丁,然后另存为 DSDT-Patch.dsl 然后使用 DiffMerge 来对比两个文件的修改代码的情况,就可以最简单的知道补丁到底修改了哪些变量. 当然读懂补丁的语法其实并不需要这样做,我们可以读一下补丁到底修改了哪些变量,做了哪些操作就可以了,这个补丁是我自己写的,所以我并不需要用 DiffMerge 来查询. 经过研究,我发现单纯用 Clover Patches 方式来修改变量是行不通的,因为例如 12345//拆分前TAH0,16 Hex: 54 41 48 30 10//拆分后TA01,8,TA02,8 Hex: 54 41 30 31 08 54 41 30 32 08 拆分前是占用5个字节,拆分后我们需要10个字节的空间,这样打补丁的话,会导致 TAH0 下面的变量被覆盖,导致出错. 那么如此大量的变量更改,我们应当如何修改呢? 我参考了 RM 给 HP ProBook 的电量补丁以及 Hotpatch 电量修补 SSDT SSDT:https://raw.githubusercontent.com/RehabMan/HP-ProBook-4x30s-DSDT-Patch/master/hotpatch/SSDT-BATT.dsl 电量补丁:https://raw.githubusercontent.com/RehabMan/HP-ProBook-4x30s-DSDT-Patch/master/patches/06_Battery.txt 发现他的解决办法如下 新建一个 SSDT 写入 EC 方法,方法中赋予我们拆分后的电池变量. 在新建的 SSDT 中复制修改好的方法. 利用 MaciASL 编译功能来协助检查缺少的 External(). 将原来调用电池变量的方法一一用 Clover Patches 更名(将原来的方法全部禁用). 将 EC 赋值的需要拆分的变量写入到 SSDT-BATT.dsl我不会写 SSDT, 但是我会抄.抄 RM 写的 SSDT 再修改 下面是 EC0 设备拆分后的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344// battery status patched for Ausu VM510LIDefinitionBlock (&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0)&#123; External(\_SB.PCI0, DeviceObj) External(\_SB.PCI0.LPCB, DeviceObj) External(\_SB.PCI0.LPCB.EC0, DeviceObj) Scope(\_SB.PCI0.LPCB.EC0) &#123; // This is an override for battery methods that access EC fields // larger than 8-bit. OperationRegion (ECOR, EmbeddedControl, Zero, 0xFF) Field (ECOR, ByteAcc, Lock, Preserve) &#123; //Offset (0x04), //CMD1, 8, //... Offset (0x93), TA00,8,TA01,8, TA20,8,TA21,8, //... Offset (0xBE), , 16, //B0TM, 16 , 16, //B0C1, 16, , 16, //B0C2, 16, B001,8,B002,8, //... Offset (0xF4), B0S0,8,B0S1,8, //Offset (0xF8), //Offset (0xFA), Offset (0xFC), B1S0,8,B1S1,8 &#125; OperationRegion (SMBX, EmbeddedControl, 0x18, 0x28) Field (SMBX, ByteAcc, NoLock, Preserve) &#123; Offset (0x04), DT01,8,DT02,8 &#125; &#125;&#125; 其中 OperationRegion (ECOR, EmbeddedControl, Zero, 0xFF) 和 OperationRegion (SMBX, EmbeddedControl, 0x18, 0x28) 原来的 DSDT 都存在,按照 RM 修改的方法,他的方式应该是从每个 Offset (0X00) 偏移量定义去写,如果偏移量下面第四个才是需要拆的,那么上面的可以使用 , 16, 这种方法来代替偏移量,好像这样就不会覆盖到原先的变量.(猜测罢了) 2017年04月30日：根据远景坛友 gujiangjiang 提醒，EC Field需要改个名字才能用，不然无效，会出现很多ACPI Error。 将上述的 ECOR 和 SMBX 重命名。 在 Clover DSDT Patches 添加如下补丁 1234567Comment:change ECOR to XCORFind:45434F52 Replace:58434F52 Comment:change SMBX to XMBXFind:534D4258 Replace:584D4258 将调用了以上变量的方法复制到 SSDT-BATT.dsl从已经打了电量补丁的 DSDT 中找出上方调用这些变量的方法所在地,不要忘记了补丁中 #fix 256 bit registers 的方法,因为电量补丁中,大于32的变量无需拆分,只需要将调动变量的代码用 WECB 方法与 RECB 方法来更改代替即可. Method (TACH, 1, Serialized) TA00 TA01 TA20 TA21 Method (_BIX, 0, NotSerialized) B001 B002 Method (BIFA, 0, NotSerialized) B0S0 B0S1 B1S0 B1S1 Method (SMBR, 3, Serialized) WECB(0x1c,256,Zero) WECB(0x1c,256,Zero) WECB(0x1c,256,Arg4) Store (RECB(0x1c,256), Index (Local0, 0x02)) Method (ECSB, 7, NotSerialized) WECB(0x1c,256,DerefOf (Index (Arg6, One))) WECB(0x44,256,DerefOf (Index (Arg6, One))) Store (RECB(0x1c,256), Index (Local1, 0x04)) Store (RECB(0x44,256), Index (Local1, 0x04)) Method (SMBW, 5, Serialized) Store (ShiftRight(Arg4,8),DT02) Store (Arg4,DT01) 总共发现6个方法,我们将这6个方法一个一个从修不好电量补丁的 DSDT 中复制到 SSDT-BATT.dsl TACH 方法 123456789101112131415161718192021222324252627282930313233343536373839404142Method (TACH, 1, Serialized)&#123; Name (_T_0, Zero) // _T_x: Emitted by ASL Compiler If (ECAV ()) &#123; While (One) &#123; Store (Arg0, _T_0) If (LEqual (_T_0, Zero)) &#123; Store (B1B2(TA00,TA01), Local0) Break &#125; ElseIf (LEqual (_T_0, One)) &#123; Store (B1B2(TA20,TA21), Local0) Break &#125; Else &#123; Return (Ones) &#125; Break &#125; Multiply (Local0, 0x02, Local0) If (LNotEqual (Local0, Zero)) &#123; Divide (0x0041CDB4, Local0, Local1, Local0) Return (Local0) &#125; Else &#123; Return (Ones) &#125; &#125; Else &#123; Return (Ones) &#125;&#125; 当你复制这个方法到 SSDT-BATT.dsl 时候,编译时会遇到一个错误.(这里我已经将拆分需要的 B1B2,WE1B,WECB,RE1B,RECB 等方法放入 Scope(\_SB.PCI0.LPCB.EC0) 域里面) 49, 6084, Object does not exist (ECAV) 看看 ECAV 是哪行调用的. 123Name (_T_0, Zero) // _T_x: Emitted by ASL CompilerIf (ECAV ())&#123; 这个是一个判断语句内嵌了一个方法的调用,初步判断 ECAV 就是一个方法,那么这个方法在哪里呢?回到我们的 DSDT.dsl 搜索 ECAV ,你会在 _SB.PCI0.LPCB.EC0 中发现 ECAV 这个方法,那么我们需要在 SSDT-BATT.dsl 中外部引入这个方法,来达到编译通过的目的. 只需要在 TACH 上方写入 External(\_SB.PCI0.LPCB.EC0.ECAV, MethodObj) 再次编译,已通过编译. 我们需要注意的是外部引入的路径与外部引入的类型. 路径在 MaciASL 中,只要你光标移动到这个方法上,程序的左下角会显示当前方法(或变量)所在的路径. 一般 Name ( ABCD , 0X10) 这类的变量引入我们使用 IntObj 类型引入. 而上述的 Method (ECAV, 0, NotSerialized) 这一类,当然是使用 MethodObj 类型引入了. 注意,复制方法过来的时候,需要注意该方法本来是在哪个域里面的,我们在 SSDT-BATT.dsl 也要将其放到哪个域里 例如:Method (_BIX, 0, NotSerialized) 这个方法是在 _SB.PCI0.BAT0 这个域里面,那么我们需要将_BIX 方法放在这个域里面 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354External(\_SB.PCI0, DeviceObj)External(\_SB.PCI0.BAT0, DeviceObj) Scope(\_SB.PCI0.BAT0) &#123; Method (_BIX, 0, NotSerialized) // _BIX: Battery Information Extended &#123; If (LNot (^^LPCB.EC0.BATP (Zero))) &#123; Return (NBIX) &#125; If (LEqual (^^LPCB.EC0.GBTT (Zero), 0xFF)) &#123; Return (NBIX) &#125; _BIF () Store (DerefOf (Index (PBIF, Zero)), Index (BIXT, One)) Store (DerefOf (Index (PBIF, One)), Index (BIXT, 0x02)) Store (DerefOf (Index (PBIF, 0x02)), Index (BIXT, 0x03)) Store (DerefOf (Index (PBIF, 0x03)), Index (BIXT, 0x04)) Store (DerefOf (Index (PBIF, 0x04)), Index (BIXT, 0x05)) Store (DerefOf (Index (PBIF, 0x05)), Index (BIXT, 0x06)) Store (DerefOf (Index (PBIF, 0x06)), Index (BIXT, 0x07)) Store (DerefOf (Index (PBIF, 0x07)), Index (BIXT, 0x0E)) Store (DerefOf (Index (PBIF, 0x08)), Index (BIXT, 0x0F)) Store (DerefOf (Index (PBIF, 0x09)), Index (BIXT, 0x10)) Store (DerefOf (Index (PBIF, 0x0A)), Index (BIXT, 0x11)) Store (DerefOf (Index (PBIF, 0x0B)), Index (BIXT, 0x12)) Store (DerefOf (Index (PBIF, 0x0C)), Index (BIXT, 0x13)) If (LEqual (DerefOf (Index (BIXT, One)), One)) &#123; Store (Zero, Index (BIXT, One)) Store (DerefOf (Index (BIXT, 0x05)), Local0) Multiply (DerefOf (Index (BIXT, 0x02)), Local0, Index (BIXT, 0x02)) Multiply (DerefOf (Index (BIXT, 0x03)), Local0, Index (BIXT, 0x03)) Multiply (DerefOf (Index (BIXT, 0x06)), Local0, Index (BIXT, 0x06)) Multiply (DerefOf (Index (BIXT, 0x07)), Local0, Index (BIXT, 0x07)) Multiply (DerefOf (Index (BIXT, 0x0E)), Local0, Index (BIXT, 0x0E)) Multiply (DerefOf (Index (BIXT, 0x0F)), Local0, Index (BIXT, 0x0F)) Divide (DerefOf (Index (BIXT, 0x02)), 0x03E8, Local0, Index (BIXT, 0x02)) Divide (DerefOf (Index (BIXT, 0x03)), 0x03E8, Local0, Index (BIXT, 0x03)) Divide (DerefOf (Index (BIXT, 0x06)), 0x03E8, Local0, Index (BIXT, 0x06)) Divide (DerefOf (Index (BIXT, 0x07)), 0x03E8, Local0, Index (BIXT, 0x07)) Divide (DerefOf (Index (BIXT, 0x0E)), 0x03E8, Local0, Index (BIXT, 0x0E)) Divide (DerefOf (Index (BIXT, 0x0F)), 0x03E8, Local0, Index (BIXT, 0x0F)) &#125; Store (B1B2(^^LPCB.EC0.B001,^^LPCB.EC0.B002), Index (BIXT, 0x08)) Store (0x0001869F, Index (BIXT, 0x09)) Return (BIXT) &#125; &#125; 复制了之后,我们还有非常多的错误需要处理 135, 6085, Object not found or not accessible from scope (^^LPCB.EC0.BATP) 代码段: If (LNot (^^LPCB.EC0.BATP (Zero))) ^^LPCB.EC0.BATP 这个方法写法中存在 ^^这两个字符,意思上级的上级域里面的,类似于相对路径, LPCB.EC.BATP 方法,完整路径就是 _SB.PCI0.LPCB.EC0.BATP,因为这个方法不在我们的 SSDT 里面,故此我们需要外部引入他.在 External 的部分加入 External(\_SB.PCI0.LPCB.EC0.BATP, MethodObj) 但是上面的 ^^LPCB.EC0.BATP 这样的调用方法猜测应该是同一 SSDT 或是在 DSDT 中存在才能这样写,如果是外部引入后,我们需要将其改成绝对路径. 将 ^^LPCB.EC0.BATP 替换成 \_SB.PCI0.LPCB.EC0.BATP. 140, 6084, Object does not exist (NBIX) 代码段:Return (NBIX) 这个返回值应该是一个变量,我们看看 DSDT 下他是如何定义的. 1234567891011121314151617181920212223Name (NBIX, Package (0x14) &#123; Zero, Zero, 0xFFFFFFFF, 0xFFFFFFFF, One, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, Zero, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot; &#125;) Name (NBIX, Package (0x14) 它是一个对象集,对象集引入的类型应当是 PkgObj 在头部外部引入部分加入 External(\_SB.PCI0.BAT0.NBIX, PkgObj) 剩下错误用同类的方法修补 最终复制完整个 SSDT-BATT.dsl 是这样的: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571// battery status patched for Ausu VM510LIDefinitionBlock (&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;batt&quot;, 0)&#123; External(\BSLF, IntObj) External(\_SB.PCI0, DeviceObj) External(\_SB.PCI0.BAT0, DeviceObj) External(\_SB.PCI0.BAT0.NBIX, PkgObj) External(\_SB.PCI0.BAT0.PBIF, PkgObj) External(\_SB.PCI0.BAT0.BIXT, PkgObj) External(\_SB.PCI0.BAT0._BIF, MethodObj) External(\_SB.PCI0.LPCB, DeviceObj) External(\_SB.PCI0.LPCB.EC0, DeviceObj) External(\_SB.PCI0.LPCB.EC0.ECAV, MethodObj) External(\_SB.PCI0.LPCB.EC0.BATP, MethodObj) External(\_SB.PCI0.LPCB.EC0.GBTT, MethodObj) External(\_SB.PCI0.LPCB.EC0.RDBL, IntObj) External(\_SB.PCI0.LPCB.EC0.RDWD, IntObj) External(\_SB.PCI0.LPCB.EC0.RDBT, IntObj) External(\_SB.PCI0.LPCB.EC0.RCBT, IntObj) External(\_SB.PCI0.LPCB.EC0.RDQK, IntObj) External(\_SB.PCI0.LPCB.EC0.MUEC, MutexObj) External(\_SB.PCI0.LPCB.EC0.PRTC, FieldUnitObj) External(\_SB.PCI0.LPCB.EC0.SBBY, IntObj) External(\_SB.PCI0.LPCB.EC0.ADDR, FieldUnitObj) External(\_SB.PCI0.LPCB.EC0.CMDB, FieldUnitObj) External(\_SB.PCI0.LPCB.EC0.SWTC, MethodObj) External(\_SB.PCI0.LPCB.EC0.BCNT, FieldUnitObj) External(\_SB.PCI0.LPCB.EC0.DAT0, FieldUnitObj) External(\_SB.PCI0.LPCB.EC0.PRT2, FieldUnitObj) External(\_SB.PCI0.LPCB.EC0.DAT1, FieldUnitObj) External(\_SB.PCI0.LPCB.EC0.ADD2, FieldUnitObj) External(\_SB.PCI0.LPCB.EC0.CMD2, FieldUnitObj) External(\_SB.PCI0.LPCB.EC0.BCN2, FieldUnitObj) External(\_SB.PCI0.LPCB.EC0.DA20, FieldUnitObj) External(\_SB.PCI0.LPCB.EC0.DA21, FieldUnitObj) External(\_SB.PCI0.LPCB.EC0.SSTS, FieldUnitObj) External(\_SB.PCI0.LPCB.EC0.SST2, FieldUnitObj) External(\_SB.PCI0.LPCB.EC0.WRBL, IntObj) External(\_SB.PCI0.LPCB.EC0.WRWD, IntObj) External(\_SB.PCI0.LPCB.EC0.WRBT, IntObj) External(\_SB.PCI0.LPCB.EC0.SDBT, IntObj) External(\_SB.PCI0.LPCB.EC0.WRQK, IntObj) Scope(\_SB.PCI0.LPCB.EC0) &#123; // This is an override for battery methods that access EC fields // larger than 8-bit. OperationRegion (ECOR, EmbeddedControl, Zero, 0xFF) Field (ECOR, ByteAcc, Lock, Preserve) &#123; //Offset (0x04), //CMD1, 8, //... Offset (0x93), TA00,8,TA01,8, TA20,8,TA21,8, //... Offset (0xBE), , 16, //B0TM, 16 , 16, //B0C1, 16, , 16, //B0C2, 16, B001,8,B002,8, //... Offset (0xF4), B0S0,8,B0S1,8, //Offset (0xF8), //Offset (0xFA), Offset (0xFC), B1S0,8,B1S1,8 &#125; OperationRegion (SMBX, EmbeddedControl, 0x18, 0x28) Field (SMBX, ByteAcc, NoLock, Preserve) &#123; Offset (0x04), DT01,8,DT02,8 &#125; // TACH methods are renamed in native DSDT, so calls land here... Method (TACH, 1, Serialized) &#123; Name (_T_0, Zero) // _T_x: Emitted by ASL Compiler If (ECAV ()) &#123; While (One) &#123; Store (Arg0, _T_0) If (LEqual (_T_0, Zero)) &#123; Store (B1B2(TA00,TA01), Local0) Break &#125; ElseIf (LEqual (_T_0, One)) &#123; Store (B1B2(TA20,TA21), Local0) Break &#125; Else &#123; Return (Ones) &#125; Break &#125; Multiply (Local0, 0x02, Local0) If (LNotEqual (Local0, Zero)) &#123; Divide (0x0041CDB4, Local0, Local1, Local0) Store(Local1, Local1) // Fix Warnings Return (Local0) &#125; Else &#123; Return (Ones) &#125; &#125; Else &#123; Return (Ones) &#125; &#125; // RE1B,RECB,WE1B,WECB Fix 64 128 256 Method Method (RE1B, 1, NotSerialized) &#123; OperationRegion(ERAM, EmbeddedControl, Arg0, 1) Field(ERAM, ByteAcc, NoLock, Preserve) &#123; BYTE, 8 &#125; Return(BYTE) &#125; Method (RECB, 2, Serialized) &#123; ShiftRight(Arg1, 3, Arg1) Name(TEMP, Buffer(Arg1) &#123; &#125;) Add(Arg0, Arg1, Arg1) Store(0, Local0) While (LLess(Arg0, Arg1)) &#123; Store(RE1B(Arg0), Index(TEMP, Local0)) Increment(Arg0) Increment(Local0) &#125; Return(TEMP) &#125; Method (WE1B, 2, NotSerialized) &#123; OperationRegion(ERAM, EmbeddedControl, Arg0, 1) Field(ERAM, ByteAcc, NoLock, Preserve) &#123; BYTE, 8 &#125; Store(Arg1, BYTE) &#125; Method (WECB, 3, Serialized) &#123; ShiftRight(Arg1, 3, Arg1) Name(TEMP, Buffer(Arg1) &#123; &#125;) Store(Arg2, TEMP) Add(Arg0, Arg1, Arg1) Store(0, Local0) While (LLess(Arg0, Arg1)) &#123; WE1B(Arg0, DerefOf(Index(TEMP, Local0))) Increment(Arg0) Increment(Local0) &#125; &#125; Method (BIFA, 0, NotSerialized) &#123; If (ECAV ()) &#123; If (BSLF) &#123; Store (B1B2(B1S0,B1S1), Local0) &#125; Else &#123; Store (B1B2(B0S0,B0S1), Local0) &#125; &#125; Else &#123; Store (Ones, Local0) &#125; Return (Local0) &#125; Method (SMBR, 3, Serialized) &#123; Store (Package (0x03) &#123; 0x07, Zero, Zero &#125;, Local0) If (LNot (ECAV ())) &#123; Return (Local0) &#125; If (LNotEqual (Arg0, RDBL)) &#123; If (LNotEqual (Arg0, RDWD)) &#123; If (LNotEqual (Arg0, RDBT)) &#123; If (LNotEqual (Arg0, RCBT)) &#123; If (LNotEqual (Arg0, RDQK)) &#123; Return (Local0) &#125; &#125; &#125; &#125; &#125; Acquire (MUEC, 0xFFFF) Store (PRTC, Local1) Store (Zero, Local2) While (LNotEqual (Local1, Zero)) &#123; Stall (0x0A) Increment (Local2) If (LGreater (Local2, 0x03E8)) &#123; Store (SBBY, Index (Local0, Zero)) Store (Zero, Local1) &#125; Else &#123; Store (PRTC, Local1) &#125; &#125; If (LLessEqual (Local2, 0x03E8)) &#123; ShiftLeft (Arg1, One, Local3) Or (Local3, One, Local3) Store (Local3, ADDR) If (LNotEqual (Arg0, RDQK)) &#123; If (LNotEqual (Arg0, RCBT)) &#123; Store (Arg2, CMDB) &#125; &#125; WECB(0x1c,256,Zero) Store (Arg0, PRTC) Store (SWTC (Arg0), Index (Local0, Zero)) If (LEqual (DerefOf (Index (Local0, Zero)), Zero)) &#123; If (LEqual (Arg0, RDBL)) &#123; Store (BCNT, Index (Local0, One)) Store (RECB(0x1c,256), Index (Local0, 0x02)) &#125; If (LEqual (Arg0, RDWD)) &#123; Store (0x02, Index (Local0, One)) Store (B1B2(DT01,DT02), Index (Local0, 0x02)) &#125; If (LEqual (Arg0, RDBT)) &#123; Store (One, Index (Local0, One)) Store (DAT0, Index (Local0, 0x02)) &#125; If (LEqual (Arg0, RCBT)) &#123; Store (One, Index (Local0, One)) Store (DAT0, Index (Local0, 0x02)) &#125; &#125; &#125; Release (MUEC) Return (Local0) &#125; Method (ECSB, 7, NotSerialized) &#123; Store (Package (0x05) &#123; 0x11, Zero, Zero, Zero, Buffer (0x20) &#123;&#125; &#125;, Local1) If (LGreater (Arg0, One)) &#123; Return (Local1) &#125; If (ECAV ()) &#123; Acquire (MUEC, 0xFFFF) If (LEqual (Arg0, Zero)) &#123; Store (PRTC, Local0) &#125; Else &#123; Store (PRT2, Local0) &#125; Store (Zero, Local2) While (LNotEqual (Local0, Zero)) &#123; Stall (0x0A) Increment (Local2) If (LGreater (Local2, 0x03E8)) &#123; Store (SBBY, Index (Local1, Zero)) Store (Zero, Local0) &#125; ElseIf (LEqual (Arg0, Zero)) &#123; Store (PRTC, Local0) &#125; Else &#123; Store (PRT2, Local0) &#125; &#125; If (LLessEqual (Local2, 0x03E8)) &#123; If (LEqual (Arg0, Zero)) &#123; Store (Arg2, ADDR) Store (Arg3, CMDB) If (LOr (LEqual (Arg1, 0x0A), LEqual (Arg1, 0x0B))) &#123; Store (DerefOf (Index (Arg6, Zero)), BCNT) WECB(0x1c,256,DerefOf (Index (Arg6, One))) &#125; Else &#123; Store (Arg4, DAT0) Store (Arg5, DAT1) &#125; Store (Arg1, PRTC) &#125; Else &#123; Store (Arg2, ADD2) Store (Arg3, CMD2) If (LOr (LEqual (Arg1, 0x0A), LEqual (Arg1, 0x0B))) &#123; Store (DerefOf (Index (Arg6, Zero)), BCN2) WECB(0x44,256,DerefOf (Index (Arg6, One))) &#125; Else &#123; Store (Arg4, DA20) Store (Arg5, DA21) &#125; Store (Arg1, PRT2) &#125; Store (0x7F, Local0) If (LEqual (Arg0, Zero)) &#123; While (PRTC) &#123; Sleep (One) Decrement (Local0) &#125; &#125; Else &#123; While (PRT2) &#123; Sleep (One) Decrement (Local0) &#125; &#125; If (Local0) &#123; If (LEqual (Arg0, Zero)) &#123; Store (SSTS, Local0) Store (DAT0, Index (Local1, One)) Store (DAT1, Index (Local1, 0x02)) Store (BCNT, Index (Local1, 0x03)) Store (RECB(0x1c,256), Index (Local1, 0x04)) &#125; Else &#123; Store (SST2, Local0) Store (DA20, Index (Local1, One)) Store (DA21, Index (Local1, 0x02)) Store (BCN2, Index (Local1, 0x03)) Store (RECB(0x44,256), Index (Local1, 0x04)) &#125; And (Local0, 0x1F, Local0) If (Local0) &#123; Add (Local0, 0x10, Local0) &#125; Store (Local0, Index (Local1, Zero)) &#125; Else &#123; Store (0x10, Index (Local1, Zero)) &#125; &#125; Release (MUEC) &#125; Return (Local1) &#125; Method (SMBW, 5, Serialized) &#123; Store (Package (0x01) &#123; 0x07 &#125;, Local0) If (LNot (ECAV ())) &#123; Return (Local0) &#125; If (LNotEqual (Arg0, WRBL)) &#123; If (LNotEqual (Arg0, WRWD)) &#123; If (LNotEqual (Arg0, WRBT)) &#123; If (LNotEqual (Arg0, SDBT)) &#123; If (LNotEqual (Arg0, WRQK)) &#123; Return (Local0) &#125; &#125; &#125; &#125; &#125; Acquire (MUEC, 0xFFFF) Store (PRTC, Local1) Store (Zero, Local2) While (LNotEqual (Local1, Zero)) &#123; Stall (0x0A) Increment (Local2) If (LGreater (Local2, 0x03E8)) &#123; Store (SBBY, Index (Local0, Zero)) Store (Zero, Local1) &#125; Else &#123; Store (PRTC, Local1) &#125; &#125; If (LLessEqual (Local2, 0x03E8)) &#123; WECB(0x1c,256,Zero) ShiftLeft (Arg1, One, Local3) Store (Local3, ADDR) If (LNotEqual (Arg0, WRQK)) &#123; If (LNotEqual (Arg0, SDBT)) &#123; Store (Arg2, CMDB) &#125; &#125; If (LEqual (Arg0, WRBL)) &#123; Store (Arg3, BCNT) WECB(0x1c,256,Arg4) &#125; If (LEqual (Arg0, WRWD)) &#123; Store (ShiftRight(Arg4,8),DT02) Store (Arg4,DT01) &#125; If (LEqual (Arg0, WRBT)) &#123; Store (Arg4, DAT0) &#125; If (LEqual (Arg0, SDBT)) &#123; Store (Arg4, DAT0) &#125; Store (Arg0, PRTC) Store (SWTC (Arg0), Index (Local0, Zero)) &#125; Release (MUEC) Return (Local0) &#125; &#125; Scope(\_SB.PCI0.BAT0) &#123; Method (_BIX, 0, NotSerialized) // _BIX: Battery Information Extended &#123; If (LNot (\_SB.PCI0.LPCB.EC0.BATP (Zero))) &#123; Return (NBIX) &#125; If (LEqual (\_SB.PCI0.LPCB.EC0.GBTT (Zero), 0xFF)) &#123; Return (NBIX) &#125; _BIF () Store (DerefOf (Index (PBIF, Zero)), Index (BIXT, One)) Store (DerefOf (Index (PBIF, One)), Index (BIXT, 0x02)) Store (DerefOf (Index (PBIF, 0x02)), Index (BIXT, 0x03)) Store (DerefOf (Index (PBIF, 0x03)), Index (BIXT, 0x04)) Store (DerefOf (Index (PBIF, 0x04)), Index (BIXT, 0x05)) Store (DerefOf (Index (PBIF, 0x05)), Index (BIXT, 0x06)) Store (DerefOf (Index (PBIF, 0x06)), Index (BIXT, 0x07)) Store (DerefOf (Index (PBIF, 0x07)), Index (BIXT, 0x0E)) Store (DerefOf (Index (PBIF, 0x08)), Index (BIXT, 0x0F)) Store (DerefOf (Index (PBIF, 0x09)), Index (BIXT, 0x10)) Store (DerefOf (Index (PBIF, 0x0A)), Index (BIXT, 0x11)) Store (DerefOf (Index (PBIF, 0x0B)), Index (BIXT, 0x12)) Store (DerefOf (Index (PBIF, 0x0C)), Index (BIXT, 0x13)) If (LEqual (DerefOf (Index (BIXT, One)), One)) &#123; Store (Zero, Index (BIXT, One)) Store (DerefOf (Index (BIXT, 0x05)), Local0) Multiply (DerefOf (Index (BIXT, 0x02)), Local0, Index (BIXT, 0x02)) Multiply (DerefOf (Index (BIXT, 0x03)), Local0, Index (BIXT, 0x03)) Multiply (DerefOf (Index (BIXT, 0x06)), Local0, Index (BIXT, 0x06)) Multiply (DerefOf (Index (BIXT, 0x07)), Local0, Index (BIXT, 0x07)) Multiply (DerefOf (Index (BIXT, 0x0E)), Local0, Index (BIXT, 0x0E)) Multiply (DerefOf (Index (BIXT, 0x0F)), Local0, Index (BIXT, 0x0F)) Divide (DerefOf (Index (BIXT, 0x02)), 0x03E8, Local0, Index (BIXT, 0x02)) Divide (DerefOf (Index (BIXT, 0x03)), 0x03E8, Local0, Index (BIXT, 0x03)) Divide (DerefOf (Index (BIXT, 0x06)), 0x03E8, Local0, Index (BIXT, 0x06)) Divide (DerefOf (Index (BIXT, 0x07)), 0x03E8, Local0, Index (BIXT, 0x07)) Divide (DerefOf (Index (BIXT, 0x0E)), 0x03E8, Local0, Index (BIXT, 0x0E)) Divide (DerefOf (Index (BIXT, 0x0F)), 0x03E8, Local0, Index (BIXT, 0x0F)) &#125; Store (B1B2(^^LPCB.EC0.B001,^^LPCB.EC0.B002), Index (BIXT, 0x08)) Store (0x0001869F, Index (BIXT, 0x09)) Return (BIXT) &#125; &#125; Method (B1B2, 2, NotSerialized) &#123; ShiftLeft (Arg1, 8, Local0) Or (Arg0, Local0, Local0) Return (Local0) &#125;&#125; 好了,以上 SSDT 编译已经通过,那么我们进行最后一步,将上述复制过来的 Method 一一的重命名,使得原有的 Method 失效,这样我们注入的 SSDT 的新 Method 才能生效. 我们需要重命名的 Method 有 123456- Method (TACH, 1, Serialized)- Method (_BIX, 0, NotSerialized)- Method (BIFA, 0, NotSerialized)- Method (SMBR, 3, Serialized)- Method (ECSB, 7, NotSerialized)- Method (SMBW, 5, Serialized) 在 config.plist 中编写补丁 ACPI &gt; DSDT &gt; Patches 1234567891011121314151617181920212223242526272829# TACHComment: change Method(TACH,1,N) to XACH, optionally pair with SSDT-BATT-VM510LI.amlFind:14 40 06 54 41 43 48 09Replace:14 40 06 58 41 43 48 09# _BIXComment: change Method(_BIX,0,N) to XBIX, optionally pair with SSDT-BATT-VM510LI.amlFind:14 49 26 5F 42 49 58 00Replace:14 49 26 58 42 49 58 00# BIFAComment: change Method(BIFA,0,N) to XIFA, optionally pair with SSDT-BATT-VM510LI.amlFind:14 27 42 49 46 41 00Replace:14 27 58 49 46 41 00# SMBRComment: change Method(SMBR,3,N) to XMBR, optionally pair with SSDT-BATT-VM510LI.amlFind:14 4B 13 53 4D 42 52 0BReplace:14 4B 13 58 4D 42 52 0B# ECSBComment: change Method(ECSB,7,N) to XCSB, optionally pair with SSDT-BATT-VM510LI.amlFind:14 4F 1A 45 43 53 42 07 Replace:14 4F 1A 58 43 53 42 07 # SMBWComment: change Method(SMBW,5,N) to XMBW, optionally pair with SSDT-BATT-VM510LI.amlFind:14 45 10 53 4D 42 57 0DReplace:14 45 10 58 4D 42 57 0D 提示,不放心自己找的代码,可以拿个从 Ubuntu 提取未修改过的 DSDT.aml, 用 Hex Fiend 来替换下,再反编译看看,反编译后无需修改,直接搜索我们修改的变量名,看是否已经改成 X 开头. 注入显卡 ID 将 GFX 更名为 IGPU 放入 SSDT-IGPU.aml 至 Clover &gt; ACPI &gt; patched 屏蔽独立显卡首先复习一下屏蔽独立显卡的方法: 引用自:屏蔽双显卡笔记本的独显 我们的目标非常简单。通常，在SSDT里，笔记本给我们提供了一个 _OFF 方法，我们可以通过调用这个方法，来切段独显的供电。最最简单的方法，就是在 相应的_INI方法里，调用_OFF方法。需要注意，这个_OFF方法，还可能会在DSDT里，或者可能会有不同的名字（如：GPOF、OPOF、_PS3，等等）。 某些_OFF方法的实现，会由于它包含了对EC(Embedded Controller)的依赖，而使得它不能在_INI方法里被调用。对于这样的情况，整个_OFF方法或者它的一部分代码，需要被移动到_REG方法里，以延迟执行（当_REG方法接收的参数Arg0 == 3 且 Arg1==1时，它会在_INI方法之后被执行）（详见ACPI规范）。对于一些情况，在_REG方法里调用_OFF的时机太迟了，从而导致要么屏蔽独显失败，要么系统五国。对于这样的情况，修改_OFF方法，移除它对于EC的依赖，将变得必要。之后，我们就可以在_INI里调用它（移除了对EC的依赖的_OFF）。同时，在_OFF里移除的代码，需要加到_REG里去。这样，虽然EC关联的代码在后（_INI后）执行（因为代码加到了_REG里，所以后执行），但却能达到更好的效果。贴子提供的例子，就是这种情况。 我是根据上面的方法来屏蔽我华硕 VM510LI 的 AMD 显卡的,很不幸的是,我的 _OFF 也包含了对 EC 的依赖,故此我在 hotpatch 当中,我并不能单纯的使用 SSDT-Disable_DGPU.aml 来禁用独立显卡. 那么该如何使用 hotpatch 方法来屏蔽我们的独立显卡呢? 于是我扒到了这个帖子:https://www.tonymacx86.com/threads/guide-disabling-discrete-graphics-in-dual-gpu-laptops.163772/page-55#post-1232166 帖子提供了一个例子.https://raw.githubusercontent.com/RehabMan/Lenovo-Z50/master/hotpatch/SSDT-NVDA.dsl 仔细查看例子中的代码会发现和上述屏蔽独立显卡不同的地方. 1234567891011External(_SB.PCI0, DeviceObj)Scope(_SB.PCI0)&#123; Device(RMD2) &#123; Name(_HID, &quot;RMD20000&quot;) Method(_INI) &#123; If (CondRefOf(\_SB.PCI0.RP05.PEGP._OFF)) &#123; \_SB.PCI0.RP05.PEGP._OFF() &#125; &#125; &#125; 看上述的代码段,他会重新定义一个设备,这个设备叫 RMD20000,然后这个设备有一个 INI 方法,里面就是调用 _OFF, 关闭显卡的系统方法. 那么,其实关闭显卡并不一定要在显卡启动的 INI 方法中运行 OFF 切断显卡电源,我估计是 PCI0 的设备是统一时间初始化的,其他设备的 INI 也一样可以将显卡电源关闭. 而我 _OFF 方法中存在一个 SGOF 的方法,这个方法里面调用了 EC0 的代码,那么需要将他去掉,故此我需要用重命名代替的方法,将原来的 SGOF 方法用重命名方法禁用掉,然后再用 SSDT 注入我们修改的 SGOF 方法, 由于 SGOF 方法中的 EC 相关的代码需要在 _REG 中执行,故此我们也需要将原有的 _REG 方法重命名禁用掉,也在 SSDT 中写入我们的 _REG 方法. 依然老方法,我不会写 SSDT, 但是我会抄.用上述的 SSDT-NVDA.dsl 来改成我们自己的 禁用显卡 SSDT. 最终写出来的 SSDT 应该就是这样 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// SSDT-DAMD: Disable AMDDefinitionBlock (&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;DAMD&quot;, 0)&#123; External(_SB.PCI0, DeviceObj) External(\_SB.PCI0.RP05.PEGP._OFF,MethodObj) External (HLRS, FieldUnitObj) External (PWEN, FieldUnitObj) Scope(_SB.PCI0) &#123; Device(RMD2) &#123; Name(_HID, &quot;RMD20000&quot;) Method(_INI) &#123; If (CondRefOf(\_SB.PCI0.RP05.PEGP._OFF)) &#123; \_SB.PCI0.RP05.PEGP._OFF() &#125; &#125; &#125; External(RP05, DeviceObj) Scope(RP05) &#123; External(PEGP, DeviceObj) Scope(PEGP) &#123; External(CCHK, MethodObj) External(ONOF, IntObj) External(LCTL,IntObj) External(ELCT, IntObj) External(SVID, IntObj) External(HVID, IntObj) External(SDID, IntObj) External(HDID, IntObj) External(LNKD, IntObj) External(LNKD, IntObj) External(LNKS, IntObj) External(SGPO, MethodObj) Method (SGOF, 0, Serialized) &#123; If (LEqual (CCHK (Zero), Zero)) &#123; Return (Zero) &#125; Store (Zero, ONOF) //Store (\_SB.PCI0.LPCB.EC0.RRAM (0x0521), Local0) //And (Local0, 0xCF, Local0) //\_SB.PCI0.LPCB.EC0.WRAM (0x0521, Local0) //\_SB.PCI0.LPCB.EC0.WRAM (0x0520, 0x91) //\_SB.PCI0.LPCB.EC0.WRAM (0x03A4, Zero) //\_SB.PCI0.LPCB.EC0.WRAM (0x03A5, Zero) Store (LCTL, ELCT) Store (SVID, HVID) Store (SDID, HDID) Store (One, LNKD) While (LNotEqual (LNKS, Zero)) &#123; Sleep (One) &#125; SGPO (HLRS, One) SGPO (PWEN, Zero) Return (Zero) &#125; &#125; &#125; External(LPCB, DeviceObj) Scope(LPCB) &#123; External(EC0, DeviceObj) Scope(EC0) &#123; External(ECFL, IntObj) External(RRAM, MethodObj) External(WRAM, MethodObj) Method (_REG, 2, NotSerialized) // _REG: Region Availability &#123; If (LEqual (Arg0, 0x03)) &#123; Store (Arg1, ECFL) &#125; If (LAnd(LEqual(Arg0,3),LEqual(Arg1,1))) &#123; Store (\_SB.PCI0.LPCB.EC0.RRAM (0x0521), Local0) And (Local0, 0xCF, Local0) \_SB.PCI0.LPCB.EC0.WRAM (0x0521, Local0) \_SB.PCI0.LPCB.EC0.WRAM (0x0520, 0x91) \_SB.PCI0.LPCB.EC0.WRAM (0x03A4, Zero) \_SB.PCI0.LPCB.EC0.WRAM (0x03A5, Zero) &#125; &#125; &#125; &#125; &#125;&#125; 然后我们需要重命名的就是两个方法,一个 SGOF, 和 _REG. 在 Clover &gt; ACPI &gt; DSDT &gt; Patches 添加如下 123456789# SGOFComment:change Method(SGOF,0,Serialized) to XGOF, optionally pair with SSDT-DAMD-VM510LI.amlFind:53474F46 08Replace:58474F46 08# _REGComment:change Method(_REG,0,Serialized) to XREG, optionally pair with SSDT-DAMD-VM510LI.amlFind:5F 52 45 47 02Replace:58 52 45 47 02 注入声卡 ID这个非常简单,只需要放入 SSDT-HDEF.aml 到 Clover &gt; ACPI &gt; patched 但是需要注意自己的 DSDT 有没有定义 HDEF 设备,如果没有,打开 SSDT-HDEF.dsl 将以下注释去掉. 12345678// Note: If your ACPI set (DSDT+SSDTs) does not define HDEF (or AZAL)// add this Device definition (by uncommenting it)////Device(_SB.PCI0.HDEF)//&#123;// Name(_ADR, 0x001b0000)// Name(_PRW, Package() &#123; 0x0d, 0x05 &#125;) // may need tweaking (or not needed)//&#125; 另外注意修改自己需要注入的 ID, 我的是4 无需修改 ID,我们只需在 SSDT-Config.aml 的 Name(AUDL, Ones) 定义我们注入的 ID 即可。（关于SSDT-Config.aml 更多的参数细节，后续会提到。 123456789101112131415161718 Method(_SB.PCI0.HDEF._DSM, 4) &#123; If (CondRefOf(\RMCF.AUDL)) &#123; If (Ones == \RMCF.AUDL) &#123; Return(0) &#125; &#125; If (!Arg2) &#123; Return (Buffer() &#123; 0x03 &#125; ) &#125; Local0 = Package() &#123; &quot;layout-id&quot;, Buffer(4) &#123; 4, 0, 0, 0 &#125;, &quot;hda-gfx&quot;, Buffer() &#123; &quot;onboard-1&quot; &#125;, &quot;PinConfigurations&quot;, Buffer() &#123; &#125;, &#125; If (CondRefOf(\RMCF.AUDL)) &#123; CreateDWordField(DerefOf(Local0[1]), 0, AUDL) AUDL = \RMCF.AUDL &#125; Return(Local0) &#125;&#125; 但是不清楚为什么上面的注入不正常,我用回 Clover 的 Devices 里面的 Inject 设置为4 RestHDA 设为 yes 终于知道为何放入上面 SSDT 后声卡依然无声，是因为 SSDT-config.dsl 问题。在下面的章节补上对这个非常非常重要的 SSDT-Config.aml 的讲解 上面的 HDEF 只是给声卡出声而已，还需要放入 SSDT-HDAU.aml 以给 HDMI 出声。 最终 HDMI 声音和声卡声音都能正常出声。 SSDT-Config 说明这个漏了说，而且这个是 Hotpatch 必用的 SSDT，因为里面包含了一些配置。 首先我们来看看 SSDT-Config 有些啥？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// configuration data for other SSDTs in this packDefinitionBlock(&quot;&quot;, &quot;SSDT&quot;, 2, &quot;hack&quot;, &quot;RMCF&quot;, 0)&#123; Device(RMCF) &#123; Name(_ADR, 0) // do not remove Method(HELP) &#123; Store(&quot;TYPE indicates type of the computer. 0: desktop, 1: laptop&quot;, Debug) Store(&quot;HIGH selects display type. 1: high resolution, 2: low resolution&quot;, Debug) Store(&quot;DPTS for laptops only. 1: enables/disables DGPU in _WAK/_PTS&quot;, Debug) Store(&quot;SHUT enables shutdown fix. 1: disables _PTS code when Arg0==5&quot;, Debug) Store(&quot;AUDL indicates audio layout-id for patched AppleHDA. Ones: no injection&quot;, Debug) Store(&quot;BKLT indicates the type of backlight control. 0: IntelBacklight, 1: AppleBacklight&quot;, Debug) Store(&quot;LMAX indicates max for IGPU PWM backlight. Ones: Use default, other values must match framebuffer&quot;, Debug) &#125; // TYPE: Indicates the type of computer... desktop or laptop // // 0: desktop // 0: 台式机 // 1: laptop // 1: 笔记本 Name(TYPE, 1) // HIGH: High resolution/low resolution selection. Affects IGPU injection. // HIGH: 高分辨率/低分辨率选择。 影响IGPU注入。 // For 1600x900+ on Sandy/Ivy, use 1 // 对于1600x900 +在Sandy / Ivy，请使用1 // For UHD/QHD+ on Haswell/Broadwell, use 1 // 对于Haswell / Broadwell的UHD / QHD +，请使用1 // Others (low resolution), use 0 // 其他（低分辨率），使用0 Name(HIGH, 0) // DPTS: For laptops only: set to 1 if you want to enable and // DPTS：仅适用于笔记本电脑：如果要启用和，请设置为1 // disable the DGPU _PTS and _WAK. // 禁用DGPU _PTS和_WAK。 // 0: does not manipulate the DGPU in _WAK and _PTS // 0：不操作_WAK和_PTS中的DGPU // 1: disables the DGPU in _WAK and enables it in _PTS // 1：禁用_WAK中的DGPU，并在_PTS中启用它 Name(DPTS, 0) // SHUT: Shutdown fix, disable _PTS code when Arg0==5 (shutdown) // SHUT：关闭修复，当Arg0 == 5（关闭）时禁用_PTS代码， // 0: does not affect _PTS behavior during shutdown // 0：在关闭期间不影响_PTS行为 // 1: disables _PTS code during shutdown // 1：在关闭期间禁用_PTS代码 Name(SHUT, 0) // AUDL: Audio Layout // AUDL：音频布局 // The value here will be used to inject layout-id for HDEF and HDAU // 这里的值将用于注入HDEF和HDAU的layout-id // If set to Ones, no audio injection will be done. // 如果设置为Ones，则不会进行音频插入。 Name(AUDL, Ones) // BKLT: Backlight control type // BKLT：背光控制类型 // 0: Using IntelBacklight.kext // 0：使用IntelBacklight.kext // 1: Using AppleBacklight.kext + AppleBacklightInjector.kext // 1：使用AppleBacklight.kext + AppleBacklightInjector.kext Name(BKLT, 0) // LMAX: Backlight PWM MAX. Must match framebuffer in use. // LMAX：背光PWM最大值。 必须匹配使用中的帧缓冲区。 // Ones: Default will be used (0x710 for Ivy/Sandy, 0xad9 for Haswell/Broadwell) // Ones：将使用默认（Ivy / Sandy 的默认值是 0x710，Haswell / Broadwell 的默认值是 0xad9） // Other values: must match framebuffer // 其他值：必须与framebuffer相匹配 Name(LMAX, Ones) &#125;&#125;//EOF 上面 RM 都注释了，我以 Google 翻译过来，方便理解。 第一个值，TYPE 从 SSDT-IGPU 调用，影响显卡 ID 的注入。查看了下代码，好像是区分是否注入高分屏 ID 有关。 第二个值，HIGH 从 SSDT-IGPU 调用，影响显卡 ID 的注入。当 TYPE 设置成笔记本才生效。 第三个值，DPTS 从 SSDT-PTSWAK 调用，这个 SSDT 是重写了睡眠和唤醒的方法，加入了一些我们补丁需要用到的代码，这里设置 1 则会在睡眠的时候开启显卡，唤醒后关闭显卡。 第四个值，SHUT 从 SSDT-PTSWAK 调用，这个 SSDT 功能同上，这里设置 1 则会在关机的时候禁用 _PTS，和 Shutdown fix 同理。 第五个值，AUDL 从 SSDT-HDAU 和 SSDT-HDEF 调用，这两个 SSDT 前者负责注入声卡 ID，后者则负责注入 HDMI 声卡 ID，而这个值就是控制两个 SSDT 注入声卡的行为，如果写 Ones 则什么都不注入，如果写 3，则声卡的 layout-id 则为 3。 第六个值，BKLT 从 SSDT-PNLF 调用，这个 SSDT 看名字大家应该都很熟悉，就是加入 PNLF 设备，用来启用我们的笔记本亮度调节驱动的，而这个值是控制亮度调节的驱动是用哪一种，0 是使用 IntelBacklight.kext，1 是使用 AppleBacklight.kext + AppleBacklightInjector.kext。 第七个值，LMAX 从 SSDT-PNLF 调用，这个 SSDT 同上，这个值是设置背光的 PWM 最大值，Ones 是使用默认值，Ivy / Sandy 的默认值是 0x710，Haswell / Broadwell 的默认值是 0xad9，你也可以设置其他值，但是这个值必须与 framebuffer 相匹配。 变频\声卡 CC 配置\USB 遮蔽器这些在黑苹果各大论坛都有介绍,我就不再论述,只需放入 SSDT 即可. 测试全部修改后,到最重要一步,测试修改的 hotpatch 是否可用. 还挺幸运的,一直写下来的笔记,就 FN 因为完全无脑抄袭没有注意自己的 Q0E 和 Q0F 是在 _SB.PCI0.LPCB.EC0 设备里面,我没把他们放到这个 Scope (域) 里面,故此不生效. 最后附上 VM510LI-Hotpatch 的 EFIVM510LI-Hotpatch.zip 参考文章 External()用法 自己动手写DSDT系列教程1-ASL（ACPI Source Language）基础篇 OS-X-Clover-Laptop-Config HP-ProBook-4x30s-DSDT-Patch Guide Using Clover to “hotpatch” ACPI]]></content>
      <categories>
        <category>黑苹果</category>
      </categories>
      <tags>
        <tag>黑苹果</tag>
        <tag>Mac</tag>
        <tag>Hackintosh</tag>
        <tag>ASUS</tag>
        <tag>VM510LI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华硕 VM510LI 屏蔽独显]]></title>
    <url>%2F2017%2F01%2F31%2FASUS-VM510LI-Disable-graphics%2F</url>
    <content type="text"><![CDATA[找到了 _OFF 方法是在 SSDT11定义的。 1234567891011121314Scope (\_SB.PCI0.RP05.PEGP)&#123; Method (_ON, 0, Serialized) // _ON_: Power On &#123; SGON () Notify (\_SB.PCI0.RP05, Zero) &#125; Method (_OFF, 0, Serialized) // _OFF: Power Off &#123; SGOF () Notify (\_SB.PCI0.RP05, Zero) &#125;&#125; 发现其中 _OFF 方法调用了 SGOF 方法。 查找到 SGOF 方法是在 SSDT10 定义的。 123456789101112131415161718192021222324252627Method (SGOF, 0, Serialized)&#123; If (LEqual (CCHK (Zero), Zero)) &#123; Return (Zero) &#125; Store (Zero, ONOF) Store (\_SB.PCI0.LPCB.EC0.RRAM (0x0521), Local0) And (Local0, 0xCF, Local0) \_SB.PCI0.LPCB.EC0.WRAM (0x0521, Local0) \_SB.PCI0.LPCB.EC0.WRAM (0x0520, 0x91) \_SB.PCI0.LPCB.EC0.WRAM (0x03A4, Zero) \_SB.PCI0.LPCB.EC0.WRAM (0x03A5, Zero) Store (LCTL, ELCT) Store (SVID, HVID) Store (SDID, HDID) Store (One, LNKD) While (LNotEqual (LNKS, Zero)) &#123; Sleep (One) &#125; SGPO (HLRS, One) SGPO (PWEN, Zero) Return (Zero)&#125; 其中调用了有四行 EC0 的代码。记下来，然后将这些代码注释掉。修改后如下： 123456789101112131415161718192021222324252627Method (SGOF, 0, Serialized)&#123; If (LEqual (CCHK (Zero), Zero)) &#123; Return (Zero) &#125; Store (Zero, ONOF) // Store (\_SB.PCI0.LPCB.EC0.RRAM (0x0521), Local0) // And (Local0, 0xCF, Local0) // \_SB.PCI0.LPCB.EC0.WRAM (0x0521, Local0) // \_SB.PCI0.LPCB.EC0.WRAM (0x0520, 0x91) // \_SB.PCI0.LPCB.EC0.WRAM (0x03A4, Zero) // \_SB.PCI0.LPCB.EC0.WRAM (0x03A5, Zero) Store (LCTL, ELCT) Store (SVID, HVID) Store (SDID, HDID) Store (One, LNKD) While (LNotEqual (LNKS, Zero)) &#123; Sleep (One) &#125; SGPO (HLRS, One) SGPO (PWEN, Zero) Return (Zero)&#125; 找到 _INI 方法是在 SSDT10 里面 1234Method (_INI, 0, NotSerialized) // _INI: Initialize&#123; Store (Zero, \_SB.PCI0.RP05.PEGP._ADR)&#125; 从中调用 _OFF 方法，修改如下： 1234567Method (_INI, 0, NotSerialized) // _INI: Initialize&#123; Store (Zero, \_SB.PCI0.RP05.PEGP._ADR) //added to turn nvidia/radeon off External(\_SB.PCI0.RP05.PEGP._OFF, MethodObj) _OFF()&#125; 其中 External(\_SB.PCI0.RP05.PEGP._OFF, MethodObj) _OFF 方法的路径必须要对，否者会出错。 找到 _REG 方法，在 DSDT 里。 1234567Method (_REG, 2, NotSerialized) // _REG: Region Availability&#123; If (LEqual (Arg0, 0x03)) &#123; Store (Arg1, ECFL) &#125;&#125; 添加之前在 SGOF 方法内注释的有关 EC0 的代码，修改后如下： 1234567891011121314151617Method (_REG, 2, NotSerialized) // _REG: Region Availability&#123; If (LEqual (Arg0, 0x03)) &#123; Store (Arg1, ECFL) &#125; //added to turn nvidia/radeon off If (LAnd(LEqual(Arg0,3),LEqual(Arg1,1))) &#123; Store (\_SB.PCI0.LPCB.EC0.RRAM (0x0521), Local0) And (Local0, 0xCF, Local0) \_SB.PCI0.LPCB.EC0.WRAM (0x0521, Local0) \_SB.PCI0.LPCB.EC0.WRAM (0x0520, 0x91) \_SB.PCI0.LPCB.EC0.WRAM (0x03A4, Zero) \_SB.PCI0.LPCB.EC0.WRAM (0x03A5, Zero) &#125;&#125; 其中 If (LAnd(LEqual(Arg0,3),LEqual(Arg1,1))) 是和上面的 If (LEqual (Arg0, 0x03)) 和 Store (Arg1, ECFL) 对应的，意思我猜测是： 上面的 LEqual (Arg0, 0x03) 成立且 Store (Arg1, ECFL) = LEqual(Arg1,1) 则执行我们的添加的 EC0 系列的代码，故此需要按情况修改 If (LAnd(LEqual(Arg0,3),LEqual(Arg1,1)))。]]></content>
      <categories>
        <category>黑苹果</category>
      </categories>
      <tags>
        <tag>黑苹果</tag>
        <tag>Mac</tag>
        <tag>Hackintosh</tag>
        <tag>ASUS</tag>
        <tag>VM510LI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华硕 VM510LI 黑苹果手记]]></title>
    <url>%2F2017%2F01%2F18%2FASUS-VM510LI-Hackintosh%2F</url>
    <content type="text"><![CDATA[前言装完我那台老掉牙的 Dell 笔记本黑苹果系统后，嫌弃它分辨率太低了，我又将我的目光转向老婆公司送的华硕 VM510LI 笔记本。😝 准备工作趁目前 Windows 平台还在的时候，先下载 AIDA64 Engineer，导出以下内容： 导出显卡 Bios 备用方法： 打开 AIDA64 Engineer； 查看，勾上状态栏。（此时软件下方应该会出现了一个框。） 右键状态栏 Video Debug。 Video Bios Dump 点开显示设备→图形处理器（GPU）查看 PCI 设备的 ID（8086-1616） 将导出的 bin 文件重命名为 8086-1616.rom 备用。 导出 ACPI 的 DSDT 和 SSDT（Windows） 建议使用 Ubuntu 方法提取 DSDT 和 SSDT 是必须导出的，但是有很多方法，我比较喜欢在 Linux 导出，不知道为啥感觉它纯正点（其实是一样的，就是个人感觉 Linux 好一点而已。） 新版的 AIDA64 Engineer 可以在 WIN10 下导出 DSDT 和 SSDT 了。老板好像是不可以的。 本笔记的 AIDA64 Engineer 版本为 5.80.4000 方法： 菜单栏工具 ACPI 浏览器 Save DSDT Save Table 一个一个 SSDT 保存。SSDT 开头才需要保存，其他不需要管。 导出 EDID 参数这个只是备用，看远景上扒贴看到很多人驱动核心显卡后内置屏幕无法显示，只能接入 HDMI 接外屏，这时候就需要注入 EDID 参数了（还有上面提取到的 Video Bios） 方法： 安装 EDID Viewer 菜单栏 Read EDID 选择 @monitor.inf 开头的选项，按 Show EDID Informations 按钮。 滚到最下面，选中 RAW Data 下方的所有16进制字符。 打开记事本粘贴进去，并去掉所有换行符和空格，开头的0x00-0x70这一段全部不要。 记下 AMD 的显卡 VEN 和 DEV 的 ID 设备管理器 显示适配器 AMD Radeon（TM）R5 M320 属性切换到硬件 ID PCI\VEN 1002&amp;DEV6665&amp;SUBSYS_192D1043&amp;REV_83 这个记下来，因为我目前不知道笔记本到底能不能驱动独立显卡，这个显卡虽然不牛，但是有比没有好嘛。 一般笔记本的做法都是屏蔽独显，但是如果能用上独显就更好。先记下，日后扒帖子找办法驱动。 妈蛋，打完上面那句话后，上网查了下我的 R5 M320，网上说比我核心显卡 HD5500更差，看来是没必要驱动了，果断屏蔽掉，浪费电。 Windows 最后以上都做完后，基本上就可以和 Windows 说拜拜了。当然我只会将 Windows 做一个镜像，等黑苹果吃不下的时候，或者急需要使用 Windows 系统的时候迅速还原。 最后你可以下载个鲁大师，保存一下配置截图，方便有啥问题到远景论坛求助。 AIDA64 则可以导出详细报告，这样可以快速确定鲁大师搞不清楚的一些芯片型号，例如我这个笔记本，鲁大师显示的是 Intel 的声卡，估计是 HDMI 搞鬼，但是实际上是 Realtek ALC233 这个声卡 AppleALC 项目有驱动，只是要慢慢试 ID 了。 Ubuntu 下提取 ACPI 下的 DSDT 和 SSDT我是不太放心 Windows 下提取的 DSDT 和 SSDT，总觉得不够全，故此我又做了个 Ubuntu 的 Live CD 启动盘，来获取 DSDT 和 SSDT。 方法见我另一篇博客：[转载][教程] [授权翻译] 使用补丁修改DSDT/SSDT [DSDT/SSDT综合教程] 从《制作Ubuntu启动U盘》看起。 我这台 VM510LI 在 Windows 下提取的 SSDT 就12个，但是在 Linux 下，dynamic 文件夹下还有三个 SSDT，总共14个。 Ubuntu 下提取 codeccodec 是制作仿冒声卡必备，虽然我这个声卡 AppleALC 项目支持，但既然已经到 Ubuntu 下了，顺手也备份下来，或许以后用得着。 方法同上。 安装 macOS Sierra一切准备好后，我们就可以开始抛弃 Windows 系统，投入 macOS Sierra 的怀抱了，当然装之前先用 PE 备份 C盘，以后需要Windows 的时候可以立刻恢复，不需要装系统，装软件那么麻烦。 安装思路构想我想法是把 Clover 安装到 U盘的 EFI 分区中，再将安装镜像也写入到 U盘中，那么以后修改了 mac 下的驱动什么的，进不去系统了，也可以用恢复盘搞回来。 实验证明，我的 U盘没法这样做，好像是需要量产后才可以一个 U盘两个分区，故此采用传统方案，将 Clover 做到 U盘里面，再将安装镜像写到硬盘里。 下载必要的软件 BootDiskUtility Clover3961_U_macOS S 10.12.2正式版(16C67).dmg 密码：l8v7 Leopard hd install helper v0.3 一个U盘（不小于8G） 安装必备的驱动文件 NullCPUPowerManagement.kext FakeSMC.kext VoodooPS2Controller.kext NullCPUPowerManagement.kext 和 FakeSMC.kext 是必须的，第一个禁用苹果原生电源驱动，第二个是骗过 macOS install 告诉他运行在一台白苹果当中。 VoodooPS2Controller.kext 是键盘驱动，不放的话，安装盘内无法用触摸板和键盘。 将 Clover 安装到 U盘 打开 BootDiskUtility 选择自己的 U盘。 点击菜单栏的 Options → Configuration 【Check at Satrtup】 勾上 【Save after DL】 勾上 点击 【Check Now】 按钮获取最新版的 Clover 点击 【OK】按钮 点击 【Format Disk】按钮【确定】等待软件写入，提示 All done 表示制作完成。 将 macOS 安装盘写入系统硬盘中（Win10为例） 右键【开始】按钮，【磁盘管理】。 选择 D盘右键【压缩卷】输入【11264】（也就是11GB）【确定】 右键压缩出来的11G 空间【新建简单卷】，点三次【下一步】，选择【不要格式化这个卷】→【下一步】→【完成】 管理员权限运行 Leopard hd install helper v0.3 文件夹下的 ddmac.exe 选择镜像文件为下载的 Clover3961_U_macOS S 10.12.2正式版(16C67)，取消所有的勾，目标分区选择刚刚压缩的卷，我这里是 E盘，注意别选错，否则会丢失数据。点击【开始】 此时程序进度条在动，中途会无响应，无需理会，等待恢复即可。 安装 macOS 插入已经安装好 Clover 的U盘。 Bios 选择此 U盘启动。 移动光标到 macOS，回车。 但是进入后立即重启，猜测是和苹果原生电源管理问题，将 NullCPUPowerManagement.kext 放入 EFI/CLOVER/kexts/10.12（10.12这个文件夹需要自己新建） 五国处理，见下一章节。 进入后点下一步，一直到选择硬盘地方，此时应当无法看到可安装的盘，点击上方菜单栏，工具，磁盘工具，找到我们需要安装的 SSD 盘，分区图选择 GUID，点击确定抹掉。后面就可以选择这个磁盘安装了。 五国处理can’t perform kext scan: no kext summary进入进行入安装盘出现五国 can’t perform kext scan: no kext summary。 出现以上五国信息，我上网查了下，有几个可能。 下载的安装镜像盘有问题，后来我校验我的镜像盘的 md5 和对方发布的时候写的一样，而且我 dell 也是用这个盘来装的，故此不应该出现这样的问题。 主板 Bios 设置问题，需要关闭 VT-d，但是我关闭了问题依旧。 内存问题，MacOS 无法正确识别笔记本的内存导致的。 后来经过排查，发现我的笔记本共8G内存，4GX2。但是其中有一条内存是直接焊在主板上，根本没法拆下来的，我再翻查了下我用 AIDA64 生成的 Reports，SDP 也只能看到添加的那条三星内存，焊接在主板上的内存是看不到的。 后来搜索后发现 Clover 是可以解决这种情况，仅需要将 SMBIOS&gt;Trust 勾上就可以解决这个五国问题了。 ACPI Error: [_DSM] Namespace lookup failure这个 _DSM 是与显卡相关的错误，遇到这个错误我们就要利用之前在 Ubuntu 提取的 DSDT 和 SSDT 来解决了。 反编译得到的 SSDT.aml 和 DSDT.aml 文件，最终得到的是 *.dsl 文件。 用 MaciASL 打开 DSDT.dsl，点击界面上方的 Patch 按钮，找到 [syn] Remove _DSM methods，点击它，再点击 Apply 应用。 修改 DSDT 和 SSDT 的方法请参考我上一篇转载的博文 :[转载][教程] [授权翻译] 使用补丁修改DSDT/SSDT [DSDT/SSDT综合教程] 将编译好的 DSDT 和 SSDT 放入到 U盘的 EFI/CLOVER/ACPI/patched 目录，**注意：SSDT的命名方式必须为 SSDT-1.aml、SSDT-2.aml。 在 Clover 的配置文件加入 SSDT 的排列顺序，ACPI&gt;SortedOrder。从 SSDT-1.aml 排序下去。DSDT name 填写 DSDT.aml。 最后勾上 Drop OEM，我理解的意思应该就是拒绝所有主板提供的 SSDT 和 DSDT。 其实去除了这个 _DSM methods 后，后面要驱动显卡还得加回来，但是这个函数的内容肯定不是原始那样，具体 ASL 编程我也不懂，都是依葫芦画瓢。 DSDT 与 SSDT 的错误修复及常用补丁应用。在利用 DSDT 和 SSDT 帮我们解决我们的驱动问题的之前，我们需要修复反编译带来的错误。 我使用 iasl -da -dl *.aml 反编译后得到的 dsl 遇到几个错误的问题这里记录一下。 首先需要将 MaciASL 的编译器改成6.1，Preference&gt;iASL&gt;ACPI 6.1。 DSDT.dsl 错误修复 4500, 6126, syntax error, unexpected PARSEOP_ZERO这里有一大段 Zero，我猜测是反编译出来的垃圾，这里可以全部删掉。 4525, 6126, syntax error, unexpected PARSEOP_ZERO同上 11019, 6126, syntax error, unexpected ‘}’ 出错代码段如下： 12345678910Method (ADBG, 1, Serialized)&#123; If (CondRefOf (MDBG)) &#123; Return (MDBG) Arg0 &#125; Return (Zero)&#125; ADBG 错误，利用 [syn]Fix ADBG Error 修复。 修复后： 123456Method (ADBG, 1, Serialized)&#123; Return(0)&#125; SSDT-3.dsl 错误修复 477, 6126, syntax error, unexpected PARSEOP_ADD 错误代码段如下 12345678If (ECON) &#123; Store (\_SB.PCI0.LPCB.H_EC.ECRD, RefOf (\_SB.PCI0.LPCB.H_EC.PLMX)) Local0 //是这行导致错误 Add (0x0AAC, Multiply (Local0, 0x0A), Local0) Store (Local0, PTMP) Return (Local0) &#125; 修改为 1234567If (ECON)&#123; Store (\_SB.PCI0.LPCB.H_EC.ECRD (RefOf (\_SB.PCI0.LPCB.H_EC.PLMX)), Local0) //改法 Add (0x0AAC, Multiply (Local0, 0x0A), Local0) Store (Local0, PTMP) Return (Local0)&#125; 549, 6126, syntax error, unexpected PARSEOP_MULTIPLY 错误代码段如下 1234567891011121314If (ECON)&#123; Store (\_SB.PCI0.LPCB.H_EC.ECRD, RefOf (\_SB.PCI0.LPCB.H_EC.PECH)) Local0 //语法错误 Multiply (Local0, 0x0A, Local0) Store (\_SB.PCI0.LPCB.H_EC.ECRD, RefOf (\_SB.PCI0.LPCB.H_EC.PECL)) Local1 //语法错误 ShiftRight (Local1, 0x02, Local1) Store (Divide (Multiply (Local1, 0x0A), 0x40, ), Local1) Add (Local0, Local1, Local0) Add (0x0AAC, Local0, Local0) Store (Local0, PTMP) Return (Local0)&#125; 修改为 123456789101112If (ECON)&#123; Store (\_SB.PCI0.LPCB.H_EC.ECRD (RefOf (\_SB.PCI0.LPCB.H_EC.PECH)),Local0) Multiply (Local0, 0x0A, Local0) Store (\_SB.PCI0.LPCB.H_EC.ECRD (RefOf (\_SB.PCI0.LPCB.H_EC.PECL)),Local1) ShiftRight (Local1, 0x02, Local1) Store (Divide (Multiply (Local1, 0x0A), 0x40, ), Local1) Add (Local0, Local1, Local0) Add (0x0AAC, Local0, Local0) Store (Local0, PTMP) Return (Local0)&#125; 475, 6086, Not a control method, cannot invoke (_SB.PCI0.LPCB.H_EC.ECRD is a Integer) 547, 6086, Not a control method, cannot invoke (_SB.PCI0.LPCB.H_EC.ECRD is a Integer) 549, 6086, Not a control method, cannot invoke (_SB.PCI0.LPCB.H_EC.ECRD is a Integer) 这三个错误其实是一个意思，就是没有找到引入的模块（瞎猜的），我的解决办法。 搜索 H_EC.ECRD 找到头部附近 External 1External (_SB_.PCI0.LPCB.H_EC.ECRD, IntObj) // Warning: Unknown object H_EC.ECRD 应该是一个方法，但是这里引入方法方式不对，应该是 MethodObj 才对。 修改为： 1External (_SB_.PCI0.LPCB.H_EC.ECRD, MethodObj) 其余 SSDT 均无错误。 常用补丁应用在 [转载][教程] [授权翻译] 使用补丁修改DSDT/SSDT [DSDT/SSDT综合教程] 中，常用补丁里面提及了一些常用补丁，并且这些补丁一般不会造成什么问题，后来我翻查了 RehabMan 的原帖，有两个补丁是有条件限制的，这些补丁要看自己的情况而添加。 引用原话 123456789&quot;Fix _WAK Arg0 v2&quot;&quot;HPET Fix&quot;&quot;SMBUS Fix&quot;&quot;IRQ Fix&quot;&quot;RTC Fix&quot;&quot;OS Check Fix&quot;&quot;Fix Mutex with non-zero SyncLevel&quot;&quot;Fix PNOT/PPNT&quot; (use only if you&apos;re dropping CPU related SSDTs) 仅适用于删除了 CPU 的 SSDT 使用。&quot;Add IMEI&quot; (do not use if your DSDT or SSDTs already have IMEI/HECI/MEI device) 如果你的 DSDT 或 SSDT 存在 IMEI/HECI/MEI 的 device 的话，就不要用这个补丁。 最终我只应用了以下补丁 1234567&quot;Fix _WAK Arg0 v2&quot;&quot;HPET Fix&quot;&quot;SMBUS Fix&quot;&quot;IRQ Fix&quot;&quot;RTC Fix&quot;&quot;OS Check Fix&quot;&quot;Fix Mutex with non-zero SyncLevel&quot; 注意，一般应用 RehabMan 大神写的补丁不会造成编译错误，但是也会有例外情况，故此应用补丁，每应用一个后都需要编译（Compile）一下，看看是否有错误。]]></content>
      <categories>
        <category>黑苹果</category>
      </categories>
      <tags>
        <tag>黑苹果</tag>
        <tag>Mac</tag>
        <tag>Hackintosh</tag>
        <tag>ASUS</tag>
        <tag>VM510LI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最近小记（2017年01月14日）]]></title>
    <url>%2F2017%2F01%2F14%2F2017-1-14-blog%2F</url>
    <content type="text"><![CDATA[农历年末了，等着放假，人都懒惰了。之前一直利用空余时间研究黑苹果，终于把辣鸡Dell 笔记本装上 macOS Sierra 驱动完所有能驱动的东东后，就好像虚脱了一样啥事都没干，说要把黑苹果的心路历程写下来的，开了个草稿现在就晾在那里了。 我装黑苹果其实是想找一款逼格好点的 Markdown 编辑器，后来发现妈蛋都好贵啊，动辄上百，轻则上几十块，完全玩不起啊。 后来找到开源的 MacDown，目前用着挺好，但是发现这家伙删除线不支持预览，胜在体积小，写 blog 方便。 MWeb Lite 也挺不错，但是那个按照建站方式管理的文档管理模式我感觉不方便，所以日常写博客还是用 MacDown。 翻了下我的 Seafile 上的个人维基，以前写了几篇关于翻墙的文章，因为站点备案了，我也不敢放这里，待会改天找我喝茶就不太好。 年初八去柬埔寨旅游，不知道有啥好玩的呢，到时候拍点好照片更新到 blog 上。 分享一首歌，我觉得挺好听，今天在网易云音乐听到。 陈奕迅-几许风雨 live 版更好听，但是无法生成外链。 总结下今年的计划： 买房 √ 生孩 X 换工作 √ 涨工资 √ 这样总结下来貌似还算可以喔。明年继续努力，装修房子要好多钱钱，生娃更需要努力工作。突然发现男人很累啊。 END]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】 VMware Fusion 8 Pro 序列号]]></title>
    <url>%2F2017%2F01%2F12%2Fvmware-fusion-8-pro-key%2F</url>
    <content type="text"><![CDATA[本文转载自 天外之家-VMware Fusion 8 Pro 序列号 下载地址http://www.vmware.com/cn/products/fusion/fusion-evaluation 提供几枚key：12345FA3RK-FHGD5-M88TZ-V4WEZ-MVAW0FU75U-4KD5L-0845Z-JEXNZ-MLKD8UV7XK-4PXEJ-080WY-4WXQT-NC0ZFVC79R-6NF81-M84XZ-VNW5G-NKUW8GC1HA-01Z14-H8D2P-04NNZ-Z6RY0]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>虚拟机、VMware</tag>
        <tag>Fusion 8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑苹果手记]]></title>
    <url>%2F2017%2F01%2F05%2FHackintosh-00%2F</url>
    <content type="text"><![CDATA[前言在3年前，接触过黑苹果，在家里的台式机里面装过一个，当时安装的是懒人版，也没有怎么系统的学习过黑苹果的相关知识，纯粹乱搞。 2016年12月份，突发奇想尝试下这台老掉牙的 Dell Inspiron 14z 5423 笔记本能否安装黑苹果，就开始尝试安装之路了。 安装 macOS Sierra我是要么不搞，要么就搞最新的，也准备常用 Mac 系统。 我下载的系统版本是《macOS Sierra 10.12.2(16C67)正式版》，这个是一个 dmg 镜像文件，引用原帖的一句话： 原版dmg镜像只能安装在 GPT 分区格式的硬盘上，懒人版cdr镜像可以安装在MBR格式和 GPT 分区格式的硬盘上。 镜像下载原帖链接：[下载] 【迎新年礼品】Clover3961_U_macOS Sierra 10.12.2(16C67)正式版dmg原版免费下载 故此我们安装的硬盘分区格式必须为 GPT。 我是安装在笔记本的SSD上，也是淘宝的二手货，挺耐用的，反正比机械硬盘快就行了。故此 笔记本配置我的笔记本的配置如下。 CPU：一般笔记本只要 CPU 是 Intel I 系列，都可以装黑苹果。 网卡：一般 Dell 都是配的 Intel 的无线网卡，图中显示的是博通的无线网卡是我从淘宝淘的，才 18 块，而且支持 5G，唯一缺点就是没有了蓝牙。想了下，不要蓝牙也没关系了，就是我的蓝牙鼠标用不了罢了。 独立显卡：笔记本就别想独立显卡能用了，因为基本上黑苹果是无法切换使用的，而且如果不屏蔽它的话，还会耗电。 声卡：IDT 的声卡有驱动，这个驱动折腾了我很久很久才完美，后续会将过程写上。 引导其实安装黑苹果遇到第一个问题就是引导，因为苹果系统只认他们自己的主板，其他主板是不认的，故此很多人第一步连进入安装都进不去。 黑苹果引导需要引导工具，需要有一个工具欺骗苹果系统，让苹果系统认为自己是跑在 Mac 的主机里。这引导系统目前有二个。 变色龙 （Chameleon） 四叶草 （Clover） 变色龙年代比较早了，前期黑苹果都用变色龙搞。 四叶草比变色龙出生迟一点，但是并不影响它的实用性。我推荐使用四叶草，因为对新手来说，他提供更多补丁功能。 对于]]></content>
      <categories>
        <category>黑苹果</category>
      </categories>
      <tags>
        <tag>黑苹果</tag>
        <tag>Mac</tag>
        <tag>Hackintosh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用 Seafile 命令行客户端同步 GitBlog]]></title>
    <url>%2F2016%2F12%2F15%2Fseaf-cli-gitblog-sync%2F</url>
    <content type="text"><![CDATA[前言由于 GitBlog 无后台编辑，故此每次在电脑写好博客，还需要用 SSH 或其他方式上传文件比较麻烦，而服务器本来就部署了 Seafile，故此可以使用 Seafile 的命令行客户端来作为同步工具。 需要使用工具 已搭建好的 Seafile 服务器（搭建方法详细请看官方手册） Seafile Terminal 客户端和 Windows 客户端（https://www.seafile.com/download/） Seaf-Cli 安装方法####下载客户端 12wget https://bintray.com/artifact/download/seafile-org/seafile/seafile-cli_4.3.2_x86-64.tar.gztar xzf seafile-cli_4.3.2_x86-64.tar.gz ####初始化和安装守护进程 12345cd seafile-cli-4.3.2# 选择存储seafile客户端设置的文件夹（例如）~/.seafile-clientmkdir ~/.seafile-client # 创建客户端设置文件夹./seaf-cli init -d ~/.seafile-client # 初始化客户端，并指定客户端的配置文件目录./seaf-cli start # 启动守护程序 ####在您的环境中安装 Seafile 客户端 12# 建立 seaf-cli 命令软连接到系统环境中ln -s `readlink -f seaf-cli` /usr/bin/ ####建立同步 到 Seafile Web 上新建 GitBlog 资料库。 点击资料库，抄下 https://demo.myseafile.com/#my-libs/lib/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx 最后面的资料库 ID。 到服务器中建立同步 12345678seaf-cli sync -l [资料库 ID] -s [Seafile 服务器 URL] -d [Gitblog目录] -u [Seafile 用户邮箱] -p [Seafile 登陆密码]#查询已同步资料库seaf-cli status#Name Status Progress#Name Statusgitblog synchronized Windows 安装 Seafile 客户端，同步 GitBlog 资料库，就可以在本地编辑 Blog 目录下的内容了。保存过几秒就刷新页面就可以看到自己写的博客，方便简单，无需再敲命令。 Seaf-Cli 开机启动 vim /etc/systemd/system/seaf-cli.service 1234567891011121314151617[Unit]Description=Seafile Terminal Client# add mysql.service or postgresql.service depending on your database to the line belowAfter=network.target seafile.service[Service]Type=oneshotExecStart=/opt/seafile-cli/seaf-cli startExecStop=/opt/seafile-cli/seaf-cli stopRemainAfterExit=yesUser=rootGroup=root[Install]WantedBy=multi-user.target systemctl daemon-reload systemctl enable seaf-cli]]></content>
      <categories>
        <category>Seafile,IT技术</category>
      </categories>
      <tags>
        <tag>Seafile</tag>
        <tag>Gitblog</tag>
        <tag>seaf-cli</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7 部署 http2]]></title>
    <url>%2F2016%2F12%2F08%2Fnginx-https-http2-installation%2F</url>
    <content type="text"><![CDATA[前言最近在折腾 GitBlog，顺便想将网站的 http1.1 协议更改为 http2，修改好 nginx 配置后发现依然还是 http1.1。后来 Google 了一番，发现 http2 需要 openssl 1.0.2 版本支持，而 Centos7 默认 yum 的 openssl 版本是 1.0.1 故此需要使用新版的 openssl 1.1.0c 编译 nginx。 下载 openssl 源码到 openssl 官网下载源码：https://www.openssl.org/source/ 123cd /usr/srcwget https://www.openssl.org/source/openssl-1.1.0c.tar.gztar xzf openssl-1.1.0c.tar.gz &amp;&amp; rm openssl-1.1.0c.tar.gz -f 卸载旧版 nginx 编译安装 nginx下载 nginx 源码包12345cd /usr/srcyum remove nginxwget http://nginx.org/download/nginx-1.10.2.tar.gztar xzf nginx-1.10.2.tar.gz &amp;&amp; rm -f nginx-1.10.2.tar.gzcd nginx-1.10.2 编译安装12345678910111213141516171819202122232425262728293031323334353637383940# 使用官方参数配置，仅添加 openssl 源码 --with-openssl=/usr/src/openssl-1.1.0c./configure --prefix=/etc/nginx \--sbin-path=/usr/sbin/nginx \--conf-path=/etc/nginx/nginx.conf \--error-log-path=/var/log/nginx/error.log \--http-log-path=/var/log/nginx/access.log \--pid-path=/var/run/nginx.pid \--lock-path=/var/run/nginx.lock \--http-client-body-temp-path=/var/cache/nginx/client_temp \--http-proxy-temp-path=/var/cache/nginx/proxy_temp \--http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp \--http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp \--http-scgi-temp-path=/var/cache/nginx/scgi_temp \--user=nginx \--group=nginx \--with-openssl=/usr/src/openssl-1.1.0c \--with-http_ssl_module \--with-http_realip_module \--with-http_addition_module \--with-http_sub_module \--with-http_dav_module \--with-http_flv_module \--with-http_mp4_module \--with-http_gunzip_module \--with-http_gzip_static_module \--with-http_random_index_module \--with-http_secure_link_module \--with-http_stub_status_module \--with-http_auth_request_module \--with-threads \--with-stream \--with-stream_ssl_module \--with-http_slice_module \--with-mail \--with-mail_ssl_module \--with-file-aio \--with-http_v2_module \--with-ipv6 make &amp;&amp; make install 查询 nginx 版本 123456[root@vultr conf.d]# nginx -Vnginx version: nginx/1.10.2built by gcc 4.8.5 20150623 (Red Hat 4.8.5-4) (GCC) built with OpenSSL 1.1.0c 10 Nov 2016TLS SNI support enabledconfigure arguments: --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-openssl=/usr/src/openssl-1.1.0c --with-http_ssl_module --with-http_realip_module --with-http_addition_module --with-http_sub_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_random_index_module --with-http_secure_link_module --with-http_stub_status_module --with-http_auth_request_module --with-threads --with-stream --with-stream_ssl_module --with-http_slice_module --with-mail --with-mail_ssl_module --with-file-aio --with-http_v2_module --with-ipv6 已经是 openssl 1.1.0c 版本了 编写 systemd 服务文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283vim /etc/systemd/system/multi-user.target.wants/nginx.service# 输入以下内容[Unit]Description=nginx - high performance web serverDocumentation=http://nginx.org/en/docs/After=network.target remote-fs.target nss-lookup.target [Service]Type=forkingPIDFile=/run/nginx.pidExecStartPre=/usr/sbin/nginx -t -c /etc/nginx/nginx.confExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.confExecReload=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPIDPrivateTmp=true [Install]WantedBy=multi-user.target[root@localhost ~]# cat /etc/systemd/system/multi-user.target.wants/nginx.service[Unit]Description=nginx - high performance web serverDocumentation=http://nginx.org/en/docs/After=network.target remote-fs.target nss-lookup.target [Service]Type=forkingPIDFile=/run/nginx.pidExecStartPre=/usr/sbin/nginx -t -c /etc/nginx/nginx.confExecStart=/usr/sbin/nginx -c /etc/nginx/nginx.confExecReload=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPIDPrivateTmp=true [Install]WantedBy=multi-user.target:wqsystemctl daemon-reloadsystemctl start nginx# 修改 nginx 主配置提取自 rpm 包vim /etc/nginx/nginx.confuser nginx;worker_processes 1;error_log /var/log/nginx/error.log warn;pid /var/run/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /var/log/nginx/access.log main; sendfile on; #tcp_nopush on; keepalive_timeout 65; #gzip on; include /etc/nginx/conf.d/*.conf;&#125;[root@vultr ~]# nginx -s reload 完成刷新一下页面，发现已经是 http2 协议了。 END]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>http2.https</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TP-Link AC1000 在锐捷网路内设置 AP 上线]]></title>
    <url>%2F2016%2F12%2F06%2Fac1000-reijie%2F</url>
    <content type="text"><![CDATA[网络拓扑及环境说明 配置目的:实现不同 SSID 分配不同 VLAN SSID = Office = Vlan 53 SSID = Guest = Vlan 54 管理 VLAN = VLAN 52 无线产品 TP-Link AC1000 TP-Link TL-AP306I-PoE 交换机产品 核心交换机: 锐捷 S8610 接入交换机: 锐捷 S3760E-24 POE供电交换机接在接入交换机后,这里并不体现. 配置要点 AC 与核心交换机连接链路为 Trunk 无线管理 VLAN,AP SSID VLAN,需要配通. 部署 AP 上线需要的 DHCP. 配置过程1. 配置核心交换机#新建管理 VLAN 52 vlan 52 name AP管理 #新建业务 VLAN 53 ; VLAN 54 vlan 53 name SSID-Office vlan 54 name SSID-Guest # 配置各 VLAN 网关 interface VLAN 52 ip address 172.16.52.254 255.255.255.0 ! interface VLAN 53 ip address 172.16.53.254 255.255.255.0 ! interface VLAN 54 ip address 172.16.54.254 255.255.255.0 # 配置 interface GigabitEthernet 2/3 为 Trunk口,且只允许 VLAN 52-54 通过. interface GigabitEthernet 2/3 switchport mode trunk switchport trunk allowed vlan remove 1-51,55-4094 # 配置各 VLAN DHCP 服务器,这里我只配置两个业务 VLAN 的 DHCP,AP 的 DHCP 由 AC 分配. ip dhcp pool vlan053 network 172.16.53.0 255.255.255.0 dns-server 202.96.128.166 default-router 172.16.53.254 ! ip dhcp pool vlan054 network 172.16.54.0 255.255.255.0 dns-server 202.96.128.166 default-router 172.16.54.254 2. 接入交换机配置# 配置 AP 管理 VLAN 与业务 VLAN. vlan 52 name AP管理 vlan 53 name SSID-Office vlan 54 name SSID-Guest # 配置 interface FastEthernet 0/17 为 Trunk,并且只允许 VLAN 52-54 通过;修改默认 VLAN 为 vlan 52 interface FastEthernet 0/17 switchport mode trunk switchport trunk native vlan 52 switchport trunk allowed vlan remove 1-51,55-4094 3. 配置 AC1000 VLAN 配置 接口配置 DHCP 服务 新建无线服务 Office-test 新建无线服务 Guest 分别将无线服务绑定到 A202 AP(TL-AP306I-PoE) 完成]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>锐捷</tag>
        <tag>TP-Link</tag>
        <tag>无线</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重庆老火锅]]></title>
    <url>%2F2016%2F12%2F05%2F2016-12-5-blog%2F</url>
    <content type="text"><![CDATA[重庆佩姐老火锅，还可以，广东人只能接受微辣。但是配菜量足，新装修环境还可以。]]></content>
      <categories>
        <category>饮食</category>
      </categories>
      <tags>
        <tag>重庆火锅</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Seafile 在线测试]]></title>
    <url>%2F2016%2F12%2F05%2Ftest%2F</url>
    <content type="text"><![CDATA[测试与 Seafile 整合使用 Seafile 同步博客文件夹,进行快捷更新博客内容。 这一段是利用 Seafile 手机客户端添加的 以下测试博客的音频功能是否正常 以下测试视频播放功能]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
        <tag>test2</tag>
        <tag>test3</tag>
        <tag>test4</tag>
        <tag>abc5</tag>
        <tag>tddd6</tag>
        <tag>teet7</tag>
        <tag>trrr8</tag>
        <tag>te21129</tag>
        <tag>tdf10</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkLite 基本语法]]></title>
    <url>%2F2016%2F12%2F05%2F%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在使用MarkLite之前你需要先了解一下关于markdown的基本语法，如果你已经掌握了，请无视本文档，如果还没有，那现在开始学习吧。 1.标题 使用 # 表示标题，一级标题使用一个 # ，二级标题使用两个 ## ，以此类推，共有六级标题。 使用 ===== 表示高阶标题，使用 --------- 表示次阶标题。 # 和标题之间最好加一个空格。不要问我为什么，貌似有时候不会被识别为标题？已经忘记自己为什么要加空格了，也许是任性。 ==== 和 ---- 表示标题时，大于等于2个都可以表示。 我通常在标题分级时使用标题标记，这个的用处很明了了。 示例11234# 这是一级标题## 这是二级标题### 这是三级标题###### 这是六级标题 这是一级标题这是二级标题这是三级标题示例212345这是一级标题========这是二级标题-------------- 这是一级标题这是二级标题2.引用使用 &gt; 表示引用， &gt;&gt; 表示引用里面再套一层引用，依次类推。 如果 &gt; 和 &gt;&gt; 嵌套使用的话，从 &gt;&gt; 退到 &gt; 时，必须之间要加一个空格或者 &gt; 作为过渡，否则默认为下一行和上一行是同一级别的引用。如示例所示。 引用标记里可以使用其他标记，如：有序列表或无序列表标记，代码标记等。示例12345&gt; 这是一级引用&gt;&gt;这是二级引用&gt;&gt;&gt; 这是三级引用&gt;这是一级引用 这是一级引用 这是二级引用 这是三级引用 这是一级引用 1.3 代码块使用三个`表示代码块。 这个符号是在Esc` 键下面，切换到英文下即可。 本文档所有使用讲解Markdown语法标记示例的地方都是使用代码块标记的。 1234var canvas = document.getElementById("canvas");var context = canvas.getContext("2d"); 1.4 行内代码使用``表示行内代码。本页部分文字中间的英文字母就是使用行内代码标记标记的。 示例 1这是`javascript`代码 这是 javascript 代码 1.5 链接使用 [](link) 表示行内链接。其中： [] 内的内容为要添加链接的文字。 link 为链接地址。 示例 我觉得MarkLite真是个牛逼的编辑器😊. 1.6 导入图片使用 ![Alt text](/path/to/img.jpg) 导入图片。其中： Alt text 为如果图片无法显示时显示的文字； /path/to/img.jpg 为图片所在路径； 点击辅助键盘中的添加图片按钮，MarkLite会自动帮你帮你把图片上传到图片存储服务器，并补齐链接，让你一步到位，是不是很方便😊 示例 1![MarkLite](https://i1.piimg.com/567954/ea65f02e0cd670a4.jpg) 1.7 粗体和斜体 使用 ** 或者 __ 表示粗体。 使用 * 或者 _ 表示斜体。 前后的 * 或 _ 与要 加粗或倾斜 的字体之间不能有空格。 示例 12**粗体1** __粗体2__*斜体1* _斜体2_ 粗体1 粗体2 斜体1 斜体2 1.8 列表使用 1\. 2\. 3. 表示有序列表，使用 * 或 - 或 + 表示无序列表。 无序列表或有序列表标记和后面的文字之间要有一个空格隔开。 有序列表标记不是按照你写的数字进行显示的，而是根据当前有序列表标记所在位置显示的，如示例1所示。 无序列表的项目符号是按照实心圆、空心圆、实心方格的层级关系递进的，如例2所示。通常情况下，同一层级使用同一种标记表示，便于自己查看和管理。 无序列表和有序列表标记的使用场景也很明了，故不多说。 示例 例1：有序列表1231\. 第一点2\. 第二点4\. 第三点 第一点 第二点 第三点 例2：无序列表1234567+ 呵呵 * 嘉嘉 - 嘻嘻 - 吼吼 - 嘎嘎 + 桀桀* 哈哈 呵呵 嘉嘉 嘻嘻 吼吼 嘎嘎 桀桀 哈哈 1.9 分割线使用 --- 或者 *** 或者 * * * 表示水平分割线。 只要 * 或者 - 大于等于三个就可组成一条平行线。 使用 --- 作为水平分割线时，要在它的前后都空一行，防止 --- 被当成标题标记的表示方式。 示例 123456---**** * * 1.11 删除线使用 ~~ 表示删除线。 注意 ~~ 和 要添加删除线的文字之间不能有空格。 我常使用在显示的告诉自己这行文字是要删除的。 示例 1~~这是一条删除线~~ 这是一条删除线 想要了解更多语法，请自行上网查阅]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World!]]></title>
    <url>%2F2016%2F12%2F03%2Foneblog%2F</url>
    <content type="text"><![CDATA[这是我的第一篇博客这是用 GitBlog 写的第一篇博客,安装不复杂,先用用再说]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Seafile Pro 部署文档]]></title>
    <url>%2F2016%2F12%2F03%2FSeafile_Pro_%E9%83%A8%E7%BD%B2%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[1. 安装环境12345wget https://bootstrap.pypa.io/get-pip.pysudo python get-pip.pysudo yum install java-1.7.0-openjdk poppler-utils python-devel python-setuptools \python-imaging MySQL-python mariadb-server python-memcached python-ldap \python-urllib3 sudo pip install boto requests vim /etc/yum.repos.d/nginx.repo 12345[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/7/x86_64/$basearch/gpgcheck=0enabled=1 yum install nginx 2. 配置 mariadb12345678# 启动 mariadbsystemctl start mariadb#设置为开机启动systemctl enable mariadb# 设置 root 密码mysqladmin -u root password "newpass" 3. 安装 Seafile Pro123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140# 创建程序目录,建议在 home 目录下,方便权限管理.mkdir -p /home/haiwen# 将下载获得的压缩包放在 /home/haiwen 目录下[root@localhost haiwen]# ll总用量 97492-rw-r--r-- 1 root root 99831302 11月 19 15:40 seafile-pro-server_6.0.3_x86-64.tar.gztar xzf seafile-pro-server_6.0.3_x86-64.tar.gz cd seafile-pro-server-6.0.3/./setup-seafile-mysql.sh Checking python on this machine ...Checking python module: setuptools ... Done.Checking python module: python-imaging ... Done.Checking python module: python-mysqldb ... Done.Checking for java ...Done.-----------------------------------------------------------------This script will guide you to setup your seafile server using MySQL.Make sure you have read seafile server manual at https://github.com/haiwen/seafile/wikiPress ENTER to continue-----------------------------------------------------------------What is the name of the server? It will be displayed on the client.3 - 15 letters or digits[ server name ] cloudWhat is the ip or domain of the server?For example: www.mycompany.com, 192.168.1.101[ This server&apos;s ip or domain ] demo.neroxps.cnWhere do you want to put your seafile data?Please use a volume with enough free space[ default &quot;/home/haiwen/seafile-data&quot; ] Which port do you want to use for the seafile fileserver?[ default &quot;8082&quot; ] -------------------------------------------------------Please choose a way to initialize seafile databases:-------------------------------------------------------[1] Create new ccnet/seafile/seahub databases[2] Use existing ccnet/seafile/seahub databases[ 1 or 2 ] 1What is the host of mysql server?[ default &quot;localhost&quot; ] What is the port of mysql server?[ default &quot;3306&quot; ] What is the password of the mysql root user?[ root password ] verifying password of user root ... doneEnter the name for mysql user of seafile. It would be created if not exists.[ default &quot;seafile&quot; ] Enter the password for mysql user &quot;seafile&quot;:[ password for seafile ] Enter the database name for ccnet-server:[ default &quot;ccnet-db&quot; ] Enter the database name for seafile-server:[ default &quot;seafile-db&quot; ] Enter the database name for seahub:[ default &quot;seahub-db&quot; ] ---------------------------------This is your configuration--------------------------------- server name: cloud server ip/domain: demo.neroxps.cn seafile data dir: /home/haiwen/seafile-data fileserver port: 8082 database: create new ccnet database: ccnet-db seafile database: seafile-db seahub database: seahub-db database user: seafile---------------------------------Press ENTER to continue, or Ctrl-C to abort---------------------------------Generating ccnet configuration ...doneSuccessly create configuration dir /home/haiwen/ccnet.Generating seafile configuration ...Done.doneGenerating seahub configuration ...----------------------------------------Now creating seahub database tables ...----------------------------------------creating seafile-server-latest symbolic link ... done-----------------------------------------------------------------Your seafile server configuration has been finished successfully.-----------------------------------------------------------------run seafile server: ./seafile.sh &#123; start | stop | restart &#125;run seahub server: ./seahub.sh &#123; start &lt;port&gt; | stop | restart &lt;port&gt; &#125;-----------------------------------------------------------------If you are behind a firewall, remember to allow input/output of these tcp ports:-----------------------------------------------------------------port of seafile fileserver: 8082port of seahub: 8000When problems occur, Refer to https://github.com/haiwen/seafile/wikifor information. 设置 Seafile 启动脚本为全局可用,方便启动,无需切换到程序目录启动 12ln -s /home/haiwen/seafile-server-latest/seafile.sh /usr/local/bin/seafileln -s /home/haiwen/seafile-server-latest/seahub.sh /usr/local/bin/seahub 4. 部署 nginx 反向代理vim /etc/nginx/conf.d/seafile.conf 输入如下内容 12345678910111213141516171819202122232425262728293031323334353637383940server &#123; listen 80; server_name demo.neroxps.cn; proxy_set_header X-Forwarded-For $remote_addr; location / &#123; fastcgi_pass 127.0.0.1:8000; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_script_name; fastcgi_param SERVER_PROTOCOL $server_protocol; fastcgi_param QUERY_STRING $query_string; fastcgi_param REQUEST_METHOD $request_method; fastcgi_param CONTENT_TYPE $content_type; fastcgi_param CONTENT_LENGTH $content_length; fastcgi_param SERVER_ADDR $server_addr; fastcgi_param SERVER_PORT $server_port; fastcgi_param SERVER_NAME $server_name; fastcgi_param REMOTE_ADDR $remote_addr; access_log /var/log/nginx/seahub.access.log; error_log /var/log/nginx/seahub.error.log; fastcgi_read_timeout 36000; &#125; location /seafhttp &#123; rewrite ^/seafhttp(.*)$ $1 break; proxy_pass http://127.0.0.1:8082; client_max_body_size 0; proxy_connect_timeout 36000s; proxy_read_timeout 36000s; proxy_send_timeout 36000s; send_timeout 36000s; &#125; location /media &#123; root /home/haiwen/seafile-server-latest/seahub; &#125;&#125; 取消默认配置文件 12mv /etc/nginx/conf.d/default.conf /etc/nginx/conf.d/default.conf.baknginx -s reload 启动 nginx 并设置为开机启动 12systemctl start nginxsystemctl enable nginx 开放防火墙规则 12firewall-cmd --permanent --add-service httpfirewall-cmd --reload 启动 Seafile 测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546seafile start# 由于我这个是免费版,所以只支持 3 用户的授权** Message: seafile-controller.c(1084): loading seafdav config from /home/haiwen/conf/seafdav.confLicense file /home/haiwen/seafile-license.txt does not exist, allow at most 3 trial users[11/22/16 15:04:50] ../common/session.c(139): using config file /home/haiwen/conf/ccnet.confStarting seafile server, please wait ...** Message: seafile-controller.c(1084): loading seafdav config from /home/haiwen/conf/seafdav.confLicense file /home/haiwen/seafile-license.txt does not exist, allow at most 3 trial usersSeafile server startedDone.seafile start-fastcgi# 启动 seahub 时会要求设置管理员账号密码LC_ALL is not set in ENV, set to en_US.UTF-8Starting seahub (fastcgi) at 127.0.0.1:8000 ...----------------------------------------It&apos;s the first time you start the seafile server. Now let&apos;s create the admin account----------------------------------------What is the email for the admin account?[ admin email ] neroxps@gmail.comWhat is the password for the admin account?[ admin password ] Enter the password again:[ admin password again ] ----------------------------------------Successfully created seafile admin----------------------------------------Seahub is startedDone. 访问 http://demo.neroxps.cn成功 可以登录 但是无法上传. 打开 http://demo.neroxps.cn/sys/settings/ 12SERVICE_URL = http://demo.neroxps.cnFILE_SERVER_ROOT = http://demo.neroxps.cn/seafhttp 测试 上传成功. 5. 配置 memcached 加速我们的 web 服务 安装 memcached 123yum install memcachedsystemctl start memcachedsystemctl enable memcached 修改 /home/haiwen/conf/seahub_settings.py 加入以下内容 123456CACHES = &#123; &apos;default&apos;: &#123; &apos;BACKEND&apos;: &apos;django.core.cache.backends.memcached.MemcachedCache&apos;, &apos;LOCATION&apos;: &apos;127.0.0.1:11211&apos;, &#125;&#125; 删除 seahub_settings.pyc 重启 seahub 使配置生效 123456789rm /home/haiwen/conf/seahub_settings.pyc -fseahub restart-fastcgi``` ### 6. 部署 office 预览功能* 安装 LibreOffice4.1+ 和 Python-UNO``` yum install libreoffice libreoffice-headless libreoffice-pyuno # centos7 默认安装 libreoffice-4.3.7.2-5.el7_2.1.x86_64 符合使用要求 安装中文字体将 windows 下需要用到的字体拷贝到 Centos 下. 1234567891011mkdir /usr/share/fonts/chinese[root@localhost chinese]# ll总用量 124316-rw-r--r-- 1 root root 16217976 7月 17 06:28 Dengb.ttf-rw-r--r-- 1 root root 15151172 7月 17 06:28 Dengl.ttf-rw-r--r-- 1 root root 16092228 7月 17 06:28 Deng.ttf-rw-r--r-- 1 root root 16247072 7月 16 19:42 msyhbd.ttc-rw-r--r-- 1 root root 12003540 7月 16 19:42 msyhl.ttc-rw-r--r-- 1 root root 23607740 7月 16 19:42 msyh.ttc-rw-r--r-- 1 root root 9751720 7月 17 06:28 simhei.ttf-rw-r--r-- 1 root root 18214356 7月 16 19:42 simsun.ttc 修改文件权限 12cd ..chmod -R 755 /usr/share/fonts/chinese 安装ttmkfdir来搜索目录中所有的字体信息，并汇总生成fonts.scale文件 12yum -y install ttmkfdirttmkfdir -e /usr/share/X11/fonts/encodings/encodings.dir 修改字体配置文件了，首先通过编辑器打开配置文件 123456789vim /etc/fonts/fonts.conf--- Font directory list --- &lt;dir&gt;/usr/share/fonts&lt;/dir&gt; &lt;dir&gt;/usr/share/fonts/chinese&lt;/dir&gt; ###加入这行 &lt;dir&gt;/usr/share/X11/fonts/Type1&lt;/dir&gt; &lt;dir&gt;/usr/share/X11/fonts/TTF&lt;/dir&gt; &lt;dir&gt;/usr/local/share/fonts&lt;/dir&gt; &lt;dir prefix=&quot;xdg&quot;&gt;fonts&lt;/dir&gt; --- the following element will be removed in the future --- &lt;dir&gt;~/.fonts&lt;/dir&gt; 刷新字体缓存 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869fc-cachefc-list/usr/share/fonts/dejavu/DejaVuSerif-Bold.ttf: DejaVu Serif:style=Bold/usr/share/fonts/liberation/LiberationSerif-Italic.ttf: Liberation Serif:style=Italic/usr/share/fonts/dejavu/DejaVuSerif-Italic.ttf: DejaVu Serif:style=Italic/usr/share/fonts/liberation/LiberationSans-Bold.ttf: Liberation Sans:style=Bold/usr/share/fonts/liberation/LiberationMono-Bold.ttf: Liberation Mono:style=Bold/usr/share/fonts/chinese/msyhbd.ttc: Microsoft YaHei UI:style=Bold,Negreta,tučné,fed,Fett,Έντονα,Negrita,Lihavoitu,Gras,Félkövér,Grassetto,Vet,Halvfet,Pogrubiony,Negrito,Полужирный,Fet,Kalın,Krepko,Lodia/usr/share/fonts/chinese/Deng.ttf: 等线,DengXian:style=Regular/usr/share/fonts/dejavu/DejaVuSansMono-BoldOblique.ttf: DejaVu Sans Mono:style=Bold Oblique/usr/share/fonts/dejavu/DejaVuSansCondensed-Oblique.ttf: DejaVu Sans,DejaVu Sans Condensed:style=Condensed Oblique,Oblique/usr/share/fonts/dejavu/DejaVuSansCondensed-Bold.ttf: DejaVu Sans,DejaVu Sans Condensed:style=Condensed Bold,Bold/usr/share/fonts/dejavu/DejaVuSansMono.ttf: DejaVu Sans Mono:style=Book/usr/share/fonts/liberation/LiberationSerif-BoldItalic.ttf: Liberation Serif:style=Bold Italic/usr/share/fonts/chinese/simsun.ttc: 宋体,SimSun:style=常规,Regular/usr/share/X11/fonts/Type1/c0611bt_.pfb: Courier 10 Pitch:style=Bold Italic/usr/share/fonts/dejavu/DejaVuSansMono-Bold.ttf: DejaVu Sans Mono:style=Bold/usr/share/fonts/chinese/msyh.ttc: 微软雅黑,Microsoft YaHei:style=Regular,Normal,obyčejné,Standard,Κανονικά,Normaali,Normál,Normale,Standaard,Normalny,Обычный,Normálne,Navadno,Arrunta/usr/share/X11/fonts/Type1/UTBI____.pfa: Utopia:style=Bold Italic/usr/share/fonts/liberation/LiberationSerif-Regular.ttf: Liberation Serif:style=Regular/usr/share/fonts/liberation/LiberationSerif-Bold.ttf: Liberation Serif:style=Bold/usr/share/fonts/chinese/simhei.ttf: 黑体,SimHei:style=Regular,Normal,obyčejné,Standard,Κανονικά,Normaali,Normál,Normale,Standaard,Normalny,Обычный,Normálne,Navadno,Arrunta/usr/share/fonts/chinese/Dengl.ttf: 等线,DengXian,DengXian Light,等线 Light:style=Light,Regular/usr/share/fonts/chinese/msyh.ttc: Microsoft YaHei UI:style=Regular,Normal,obyčejné,Standard,Κανονικά,Normaali,Normál,Normale,Standaard,Normalny,Обычный,Normálne,Navadno,Arrunta/usr/share/fonts/liberation/LiberationMono-Italic.ttf: Liberation Mono:style=Italic/usr/share/fonts/google-crosextra-caladea/Caladea-Bold.ttf: Caladea:style=Bold/usr/share/X11/fonts/Type1/c0419bt_.pfb: Courier 10 Pitch:style=Regular/usr/share/fonts/dejavu/DejaVuSans.ttf: DejaVu Sans:style=Book/usr/share/fonts/google-crosextra-carlito/Carlito-BoldItalic.ttf: Carlito:style=Bold Italic/usr/share/fonts/chinese/msyhl.ttc: 微软雅黑,Microsoft YaHei,Microsoft YaHei Light,微软雅黑 Light:style=Light,Regular/usr/share/fonts/chinese/msyhbd.ttc: 微软雅黑,Microsoft YaHei:style=Bold,Negreta,tučné,fed,Fett,Έντονα,Negrita,Lihavoitu,Gras,Félkövér,Grassetto,Vet,Halvfet,Pogrubiony,Negrito,Полужирный,Fet,Kalın,Krepko,Lodia/usr/share/fonts/liberation/LiberationSans-BoldItalic.ttf: Liberation Sans:style=Bold Italic/usr/share/fonts/google-crosextra-carlito/Carlito-Regular.ttf: Carlito:style=Regular/usr/share/fonts/dejavu/DejaVuSerifCondensed-BoldItalic.ttf: DejaVu Serif,DejaVu Serif Condensed:style=Condensed Bold Italic,Bold Italic/usr/share/X11/fonts/Type1/c0648bt_.pfb: Bitstream Charter:style=Regular/usr/share/fonts/chinese/simsun.ttc: 新宋体,NSimSun:style=常规,Regular/usr/share/fonts/chinese/msyhl.ttc: Microsoft YaHei UI,Microsoft YaHei UI Light:style=Light,Regular/usr/share/fonts/dejavu/DejaVuSerifCondensed-Bold.ttf: DejaVu Serif,DejaVu Serif Condensed:style=Condensed Bold,Bold/usr/share/fonts/chinese/Dengb.ttf: 等线,DengXian:style=Bold/usr/share/fonts/google-crosextra-carlito/Carlito-Italic.ttf: Carlito:style=Italic/usr/share/fonts/opensymbol/opens___.ttf: OpenSymbol:style=Regular/usr/share/fonts/dejavu/DejaVuSerif.ttf: DejaVu Serif:style=Book/usr/share/fonts/dejavu/DejaVuSansMono-Oblique.ttf: DejaVu Sans Mono:style=Oblique/usr/share/fonts/dejavu/DejaVuSans-Bold.ttf: DejaVu Sans:style=Bold/usr/share/fonts/google-crosextra-caladea/Caladea-Regular.ttf: Caladea:style=Regular/usr/share/X11/fonts/Type1/cursor.pfa: Cursor:style=Regular/usr/share/fonts/dejavu/DejaVuSerifCondensed.ttf: DejaVu Serif,DejaVu Serif Condensed:style=Condensed,Book/usr/share/X11/fonts/Type1/UTB_____.pfa: Utopia:style=Bold/usr/share/fonts/liberation/LiberationMono-Regular.ttf: Liberation Mono:style=Regular/usr/share/X11/fonts/Type1/c0583bt_.pfb: Courier 10 Pitch:style=Bold/usr/share/fonts/dejavu/DejaVuSerifCondensed-Italic.ttf: DejaVu Serif,DejaVu Serif Condensed:style=Condensed Italic,Italic/usr/share/X11/fonts/Type1/UTI_____.pfa: Utopia:style=Italic/usr/share/fonts/google-crosextra-caladea/Caladea-Italic.ttf: Caladea:style=Italic/usr/share/fonts/google-crosextra-carlito/Carlito-Bold.ttf: Carlito:style=Bold/usr/share/fonts/liberation/LiberationSans-Italic.ttf: Liberation Sans:style=Italic/usr/share/X11/fonts/Type1/c0582bt_.pfb: Courier 10 Pitch:style=Italic/usr/share/fonts/dejavu/DejaVuSansCondensed.ttf: DejaVu Sans,DejaVu Sans Condensed:style=Condensed,Book/usr/share/fonts/dejavu/DejaVuSerif-BoldItalic.ttf: DejaVu Serif:style=Bold Italic/usr/share/fonts/dejavu/DejaVuSans-ExtraLight.ttf: DejaVu Sans,DejaVu Sans Light:style=ExtraLight/usr/share/fonts/liberation/LiberationMono-BoldItalic.ttf: Liberation Mono:style=Bold Italic/usr/share/fonts/dejavu/DejaVuSansCondensed-BoldOblique.ttf: DejaVu Sans,DejaVu Sans Condensed:style=Condensed Bold Oblique,Bold Oblique/usr/share/X11/fonts/Type1/c0633bt_.pfb: Bitstream Charter:style=Bold Italic/usr/share/fonts/liberation/LiberationSans-Regular.ttf: Liberation Sans:style=Regular/usr/share/X11/fonts/Type1/c0649bt_.pfb: Bitstream Charter:style=Italic/usr/share/fonts/dejavu/DejaVuSans-Oblique.ttf: DejaVu Sans:style=Oblique/usr/share/X11/fonts/Type1/c0632bt_.pfb: Bitstream Charter:style=Bold/usr/share/fonts/google-crosextra-caladea/Caladea-BoldItalic.ttf: Caladea:style=Bold Italic,Italic/usr/share/fonts/dejavu/DejaVuSans-BoldOblique.ttf: DejaVu Sans:style=Bold Oblique/usr/share/X11/fonts/Type1/UTRG____.pfa: Utopia:style=Regular 看到新添加的字体即可. 测试预览,已正常 7. 部署在线 libreoffice 编辑 给域名申请一个 SSL 证书,这里我已经有,不演示了. 我给 libreoffice 的域名是 test.neroxps.cn 已经申请 letsencrypt 的 SSL 证书.并且放到该目录/etc/ssl/test.neroxps.cn 使用 Nginx 的网上服务collabora，配置文件例如： 12345678910111213141516171819202122232425262728293031vim /etc/nginx/conf.d/office.confserver &#123;listen 443 ssl;server_name test.neroxps.cn;ssl_certificate /etc/ssl/test.neroxps.cn/fullchain1.pem;ssl_certificate_key /etc/ssl/test.neroxps.cn/privkey1.pem;# static fileslocation ^~ /loleaflet &#123; proxy_pass https://localhost:9980; proxy_set_header Host $http_host;&#125;# WOPI discovery URLlocation ^~ /hosting/discovery &#123; proxy_pass https://localhost:9980; proxy_set_header Host $http_host;&#125;# websockets, download, presentation and image uploadlocation ^~ /lool &#123; proxy_pass https://localhost:9980; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_set_header Host $http_host;&#125;&#125;# 重置 nginx 配置nginx -s reload 修改防火墙启用 https 服务 12345firewall-cmd --permanent --add-service httpsfirewall-cmd --reload``` * 安装 docker yum -y install docker1234567* 注册阿里云开发者帐号帐号https://cr.console.aliyun.com/登陆后取得专属加速器地址，类似这样https://xxxxxx.mirror.aliyuncs.com* 配置Docker加速器 vim /etc/sysconfig/docker OPTIONS=’–selinux-enabled –log-driver=journald –registry-mirror=https://xxxxxx.mirror.aliyuncs.com‘ #修改 OPTIONS 这句,添加阿里云加速器12 * 启动 docker 并设置为开机启动 systemctl start dockersystemctl enable docker123* 安装/启动 libreoffice 在线服务 下载collabora/codedocker pull collabora/code 启动 collabora/code 注意,这里的域名是 seafile 的域名,并不是 office 在线服务的域名docker run -d -t -p 9980:9980 -e “domain=demo\.neroxps\.cn” –restart always –cap-add MKNOD collabora/code12345 * 修改 seahub_settings.py 启用在线 office 编辑功能.vim /home/haiwen/conf/seahub_settings.py** 注意修改 OFFICE_WEB_APP_BASE_URL 为 上面 nginx 的域名 ** Enable LibreOffice OnlineENABLE_OFFICE_WEB_APP = True Url of LibreOffice Online’s discovery pageThe discovery page tells Seafile how to interact with LibreOffice Online when view file onlineYou should change https://collabora-online.seafile.com/hosting/discovery to your actual LibreOffice Online server addressOFFICE_WEB_APP_BASE_URL = ‘https://test.neroxps.cn/hosting/discovery‘ Expiration of WOPI access tokenWOPI access token is a string used by Seafile to determine the file’sidentity and permissions when use LibreOffice Online view it onlineAnd for security reason, this token should expire after a set time periodWOPI_ACCESS_TOKEN_EXPIRATION = 30 * 60 # seconds List of file formats that you want to view through LibreOffice OnlineYou can change this value according to your preferencesAnd of course you should make sure your LibreOffice Online supports to previewthe files with the specified extensionsOFFICE_WEB_APP_FILE_EXTENSION = (‘ods’, ‘xls’, ‘xlsb’, ‘xlsm’, ‘xlsx’,’ppsx’, ‘ppt’, ‘pptm’, ‘pptx’, ‘doc’, ‘docm’, ‘docx’) Enable edit files through LibreOffice OnlineENABLE_OFFICE_WEB_APP_EDIT = True types of files should be editable through LibreOffice OnlineOFFICE_WEB_APP_EDIT_FILE_EXTENSION = (‘ods’, ‘xls’, ‘xlsb’, ‘xlsm’, ‘xlsx’,’ppsx’, ‘ppt’, ‘pptm’, ‘pptx’, ‘doc’, ‘docm’, ‘docx’)``` 删除 seahub_settings.pyc 文件 rm seahub_settings.pyc -f 重启 seahub seahub restart-fastcgi]]></content>
      <categories>
        <category>Seafile</category>
      </categories>
      <tags>
        <tag>Seafile</tag>
        <tag>Pro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Seafile 批量导入账号名称及电话号码]]></title>
    <url>%2F2016%2F11%2F05%2FSeafile-import-Username-phonenumber%2F</url>
    <content type="text"><![CDATA[前言seafile 可以使用 CSV 导入用户名密码来新建用户,但是只能导入用户名和密码,名称则无法导入,但是用户名只能用邮箱这点不是很方便,故此需要找到一个批量导入账号名称的办法. 数据库结构seafile 的账号和密码均存储在 mysql 的 ccnet-db 数据库内,但账号的详细信息例如名称、电话、部门这些信息是存储在 seahub-db 数据库里面. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768MariaDB [(none)]&gt; use seahub-dbReading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedMariaDB [seahub-db]&gt; show tables;+-------------------------------------------+| Tables_in_seahub-db |+-------------------------------------------+| api2_token || api2_tokenv2 || avatar_avatar || avatar_groupavatar || base_clientlogintoken || base_commandslastcheck || base_devicetoken || base_filecomment || base_filediscuss || base_groupenabledmodule || base_innerpubmsg || base_innerpubmsgreply || base_userenabledmodule || base_userlastlogin || base_userstarredfiles || captcha_captchastore || constance_config || contacts_contact || django_content_type || django_migrations || django_session || group_groupmessage || group_messageattachment || group_messagereply || group_publicgroup || institutions_institution || institutions_institutionadmin || invitations_invitation || message_usermessage || message_usermsgattachment || message_usermsglastcheck || notifications_notification || notifications_usernotification || options_useroptions || organizations_orgmemberquota || post_office_attachment || post_office_attachment_emails || post_office_email || post_office_emailtemplate || post_office_log || profile_detailedprofile || profile_profile || registration_registrationprofile || share_anonymousshare || share_fileshare || share_orgfileshare || share_privatefiledirshare || share_uploadlinkshare || sysadmin_extra_userloginlog || termsandconditions_termsandconditions || termsandconditions_usertermsandconditions || two_factor_phonedevice || two_factor_staticdevice || two_factor_statictoken || two_factor_totpdevice || wiki_groupwiki || wiki_personalwiki |+-------------------------------------------+57 rows in set (0.00 sec) 其中profile_profile是存放个人资料的表,而profile_detailedprofile是存放电话号码的表格,他们均以一个字段user(用户名邮箱)来做标识达成一一对应. 1234567891011121314151617181920212223242526272829MariaDB [(none)]&gt; use seahub-db;Reading table information for completion of table and column namesYou can turn off this feature to get a quicker startup with -ADatabase changedMariaDB [seahub-db]&gt; desc profile_profile;+---------------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+---------------+--------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || user | varchar(254) | NO | UNI | NULL | || nickname | varchar(64) | NO | | NULL | || intro | longtext | NO | | NULL | || lang_code | longtext | YES | | NULL | || login_id | varchar(225) | YES | UNI | NULL | || contact_email | varchar(225) | YES | MUL | NULL | || institution | varchar(225) | YES | MUL | NULL | |+---------------+--------------+------+-----+---------+----------------+8 rows in set (0.00 sec)MariaDB [seahub-db]&gt; desc profile_detailedprofile;+------------+--------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+------------+--------------+------+-----+---------+----------------+| id | int(11) | NO | PRI | NULL | auto_increment || user | varchar(255) | NO | MUL | NULL | || department | varchar(512) | NO | | NULL | || telephone | varchar(100) | NO | | NULL | |+------------+--------------+------+-----+---------+----------------+4 rows in set (0.00 sec) 那么我们只需要将我们的信息导入到这两个表就可以了 导入数据比如现在我们需要导入用户名:zhangsan@domain.com;名称:张三;电话:12345678.名称是在profile_profile里面字段是nickname,而电话是在profile_detailedprofile里面,字段是telephone. 1234# 名称导入insert into profile_profile (user,nickname) values (&apos;zhangsan@domain.com&apos;,&apos;张三&apos;)# 电话号码导入insert into profile_detailedprofile (user,telephone) values (&apos;zhangsan@domain.com&apos;,&apos;12345678&apos;) 如果多条数据导入可以这样写 1234# 名称导入insert into profile_profile (user,nickname) values (&apos;zhangsan@domain.com&apos;,&apos;张三&apos;),(&apos;lisi@domain.com&apos;,&apos;李四&apos;)# 电话号码导入insert into profile_detailedprofile (user,telephone) values (&apos;zhangsan@domain.com&apos;,&apos;12345678&apos;),(&apos;lisi@domain.com&apos;,&apos;87654321&apos;) 导入完成后打开用户页面就能见到用户名称和电话号码,其他字段的属性导入也是差不多 参考文献mysql批量插入(insert)与批量更新(update)的例子 修改记录 2016年11月7日:经 Seafile 中文论坛兄弟(skipto)提醒,数据库 id 字段是自动添加,无需导入,把 id 导入字段删除.]]></content>
      <categories>
        <category>Seafile</category>
      </categories>
      <tags>
        <tag>Seafile</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欢迎使用GitBlog]]></title>
    <url>%2F2015%2F07%2F31%2Fwelcome%2F</url>
    <content type="text"><![CDATA[一. 简介GitBlog是一个简单易用的Markdown博客系统，它不需要数据库，没有管理后台功能，更新博客只需要添加你写好的Markdown文件即可。它摆脱了在线编辑器排版困难，无法实时预览的缺点，一切都交给Markdown来完成，一篇博客就是一个Markdown文件。同时也支持评论，代码高亮，数学公式，页面PV统计等常用功能。GitBlog提供了不同的主题样式，你可以根据自己的喜好配置，如果你想自己制作博客主题，也是非常容易的。GitBlog还支持整站静态导出，你完全可以导出整站静态网页部署到Github Pages。 二. 功能特点 使用Markdown 评论框 代码高亮 PV统计 Latex数学公式 自制主题 响应式 全站静态导出 良好的SEO 三. GitBlog优势 无需数据库，系统更轻量，移植更方便 使用Markdown编写，摆脱后台编辑排版困难，无法实时预览的缺点 可全站静态导出 配置灵活，可自由开关某些功能 多主题支持，可自制主题 博客，分类，标签，归档 四. 环境要求PHP 5.2.4+ 五. 安装步骤 下载GitBlog源代码 解压上传到你的PHP网站根目录 打开浏览器，访问网站首页 上传Markdown文件到posts文件夹 六. 详细说明1. 安装2. 目录结构3. 配置说明4. 编写博客5. 评论，订阅，统计等6. 缓存机制7. 全站静态导出8. 主题制作9. 在Nginx上运行GitBlog10. 在Apache上运行GitBlog11. 在SAE上运行GitBlog12. 使用GitBlog和Github Pages搭建博客13. Gitblog升级14. 从wordpress导入 七. 问题及bug反馈如果在实际使用过程中对GitBlog有新的功能需求，或者在使用GitBlog的过程中发现了Bug，欢迎反馈给我。可以直接在Github上提交，也可以发邮件至164068300[AT]qq.com与我取得联系，我将及时回复。如果你自己制作了漂亮好用的主题，也非常欢迎你提交给我，我会在这里展示你的主题链接。如果你正在使用GitBlog，也可以告诉我，我将也会在这里列出使用者名单。如果你想和其他GitBlog使用者讨论交流，欢迎加入QQ群84692078。 八. 使用者列表 Weeds 橙子 jockchou GitBlog Doc zxy 九. 感谢GitBlog的成长需要喜欢Markdown，喜欢写博客的各位亲们支持！感谢你们使用GitBlog，感激你们对Gitblog的良好建议与Bug反馈。 QQ群：84692078作者邮箱：164068300[AT]qq.com]]></content>
      <categories>
        <category>GitBlog</category>
      </categories>
      <tags>
        <tag>GitBlog</tag>
      </tags>
  </entry>
</search>